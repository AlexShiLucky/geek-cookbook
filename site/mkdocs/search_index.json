{
    "docs": [
        {
            "location": "/", 
            "text": "Index\n\n\nThe \"\nGeek's Cookbook\n\" is a collection of guides for establishing your own highly-available \"private cloud\" \n1\n. This cloud enables you to run self-hosted services such as \nGitLab\n, \nPlex\n, \nNextCloud\n, etc.\n\n\nWho is this for?\n\n\nYou already have a familiarity with concepts such as \nvirtual\n \nmachines\n, \nDocker\n containers, \nLetsEncrypt SSL certificates\n, databases, and command-line interfaces.\n\n\nYou've probably played with self-hosting some mainstream apps yourself, like \nPlex\n, \nOwnCloud\n, \nWordpress\n or even \nSandStorm\n.\n\n\nWhy should I read this?\n\n\nSo if you're familiar enough with the tools, and you've done self-hosting before, why would you read this book?\n\n\n\n\nYou want to upskill. You want to do container orchestration, LetsEncrypt certificates, git collaboration.\n\n\nYou want to play. You want a safe sandbox to test new tools, keeping the ones you want and tossing the ones you don't.\n\n\nYou want reliability. Once you go from \nplaying\n with a tool to actually \nusing\n it, you want it to be available when you need it. Having to \"\nquickly ssh into the host and restart the webserver\n\" doesn't cut it when your wife wants to know why her phone won't sync!\n\n\n\n\nWhat do you want from me?\n\n\nI want your money.\n\n\nNo, seriously (\nbut yes, I do want your money - see below\n), If the above applies to you, then you're like me. I want everything I wrote above, so I ended up learning all this as I went along. I enjoy it, and I'm good at it. So I created this website, partly to make sure I documented my own setup properly.\n\n\nHow can I support you?\n\n\nBuy my book \ud83d\udcd6\n\n\nI'm also writing it as a formal book, on Leanpub (\nhttps://leanpub.com/geeks-cookbook\n). Buy it for $0.99 (which is really just a token gesture of support) - you can get it for free (in PDF, mobi, or epub format), or pay me what you think it's worth!\n\n\nPatreonize me \ud83d\udcb0\n\n\nBecome a Patron!\n\n- \nMy Patreon page\n!\n\n\nHire me \ud83c\udfe2\n\n\nNeed some system design work done? I do freelance consulting - \ncontact\n me for details.\n\n\n\n\n\n\n\n\n\n\nSorry for the buzzword, I couldn't think of a better description!", 
            "title": "Home"
        }, 
        {
            "location": "/#index", 
            "text": "The \" Geek's Cookbook \" is a collection of guides for establishing your own highly-available \"private cloud\"  1 . This cloud enables you to run self-hosted services such as  GitLab ,  Plex ,  NextCloud , etc.", 
            "title": "Index"
        }, 
        {
            "location": "/#who-is-this-for", 
            "text": "You already have a familiarity with concepts such as  virtual   machines ,  Docker  containers,  LetsEncrypt SSL certificates , databases, and command-line interfaces.  You've probably played with self-hosting some mainstream apps yourself, like  Plex ,  OwnCloud ,  Wordpress  or even  SandStorm .", 
            "title": "Who is this for?"
        }, 
        {
            "location": "/#why-should-i-read-this", 
            "text": "So if you're familiar enough with the tools, and you've done self-hosting before, why would you read this book?   You want to upskill. You want to do container orchestration, LetsEncrypt certificates, git collaboration.  You want to play. You want a safe sandbox to test new tools, keeping the ones you want and tossing the ones you don't.  You want reliability. Once you go from  playing  with a tool to actually  using  it, you want it to be available when you need it. Having to \" quickly ssh into the host and restart the webserver \" doesn't cut it when your wife wants to know why her phone won't sync!", 
            "title": "Why should I read this?"
        }, 
        {
            "location": "/#what-do-you-want-from-me", 
            "text": "I want your money.  No, seriously ( but yes, I do want your money - see below ), If the above applies to you, then you're like me. I want everything I wrote above, so I ended up learning all this as I went along. I enjoy it, and I'm good at it. So I created this website, partly to make sure I documented my own setup properly.", 
            "title": "What do you want from me?"
        }, 
        {
            "location": "/#how-can-i-support-you", 
            "text": "", 
            "title": "How can I support you?"
        }, 
        {
            "location": "/#buy-my-book", 
            "text": "I'm also writing it as a formal book, on Leanpub ( https://leanpub.com/geeks-cookbook ). Buy it for $0.99 (which is really just a token gesture of support) - you can get it for free (in PDF, mobi, or epub format), or pay me what you think it's worth!", 
            "title": "Buy my book \ud83d\udcd6"
        }, 
        {
            "location": "/#patreonize-me", 
            "text": "Become a Patron! \n-  My Patreon page !", 
            "title": "Patreonize me \ud83d\udcb0"
        }, 
        {
            "location": "/#hire-me", 
            "text": "Need some system design work done? I do freelance consulting -  contact  me for details.      Sorry for the buzzword, I couldn't think of a better description!", 
            "title": "Hire me \ud83c\udfe2"
        }, 
        {
            "location": "/README/", 
            "text": "How to read this book\n\n\nStructure\n\n\n\n\n\"Recipies\" generally follow on from each other. I.e., if a particular recipe requires a mail server, that mail server would have been described in an earlier recipe.\n\n\nEach recipe contains enough detail in a single page to take a project from start to completion.\n\n\nWhen there are optional add-ons/integrations possible to a project (i.e., the addition of \"smart LED bulbs\" to Home Assistant), this will be reflected either as a brief \"Chef's note\" after the recipe, or if they're substantial enough, as a sub-page of the main project\n\n\n\n\nConventions\n\n\n\n\nWhen creating swarm networks, we always explicitly set the subnet in the overlay network, to avoid potential conflicts (which docker won't prevent, but which will generate errors) (\nhttps://github.com/moby/moby/issues/26912\n)", 
            "title": "README"
        }, 
        {
            "location": "/README/#how-to-read-this-book", 
            "text": "", 
            "title": "How to read this book"
        }, 
        {
            "location": "/README/#structure", 
            "text": "\"Recipies\" generally follow on from each other. I.e., if a particular recipe requires a mail server, that mail server would have been described in an earlier recipe.  Each recipe contains enough detail in a single page to take a project from start to completion.  When there are optional add-ons/integrations possible to a project (i.e., the addition of \"smart LED bulbs\" to Home Assistant), this will be reflected either as a brief \"Chef's note\" after the recipe, or if they're substantial enough, as a sub-page of the main project", 
            "title": "Structure"
        }, 
        {
            "location": "/README/#conventions", 
            "text": "When creating swarm networks, we always explicitly set the subnet in the overlay network, to avoid potential conflicts (which docker won't prevent, but which will generate errors) ( https://github.com/moby/moby/issues/26912 )", 
            "title": "Conventions"
        }, 
        {
            "location": "/whoami/", 
            "text": "Welcome to Funky Penguin's Geek Cookbook\n\n\nHello world,\n\n\nI'm \nDavid\n.\n\n\nI've spent 20+ years working with technology. My current role is \nSenior Infrastructure Architect\n at \nProphecy Networks Ltd\n in New Zealand, with a specific interest in networking, systems, open-source, and business management.\n\n\nI've had a \nbook published\n, and I \nblog\n on topics that interest me.\n\n\nWhy Funky Penguin?\n\n\nMy first \"real\" job, out of high-school, was working the IT helpdesk in a typical pre-2000 organization in South Africa. I enjoyed experimenting with Linux, and cut my teeth by replacing the organization's Exchange 5.5 mail platform with a 15-site \nqmail-ldap\n cluster, with \namavis\n virus-scanning.\n\n\nOne of our suppliers asked me to quote to do the same for their organization. With nothing to loose, and half-expecting to be turned down, I quoted a generous fee, and chose a cheeky company name. The supplier immediately accepted my quote, and the name (\"\nFunky Penguin\n\") stuck.\n\n\nTechnical Documentation\n\n\nDuring the same \"real\" job above, I wanted to deploy \njabberd\n, for internal instant messaging within the organization, and as a means to control the sprawl of ad-hoc instant-messaging among staff, using ICQ, MSN, and Yahoo Messenger.\n\n\nTo get management approval to deploy, I wrote a logger (with web UI) for jabber conversations (\nBandersnatch\n), and a \n75-page user manual\n (in \nDocbook XML\n for a spunky Russian WinXP jabber client, \nJAJC\n.\n\n\nDue to my contributions to \nphpList\n, I was approached in 2011 by \nPackt Publishing\n, to \nwrite a book\n about using PHPList.\n\n\nContact Me\n\n\nContact me by:\n\n\n\n\nEmail (\n)\n\n\nTwitter (\n@funkypenguin\n)\n\n\nMastodon (\n@davidy@funkypenguin.co.nz\n)\n\n\n\n\nOr by using the form below:", 
            "title": "whoami"
        }, 
        {
            "location": "/whoami/#welcome-to-funky-penguins-geek-cookbook", 
            "text": "", 
            "title": "Welcome to Funky Penguin's Geek Cookbook"
        }, 
        {
            "location": "/whoami/#hello-world", 
            "text": "I'm  David .  I've spent 20+ years working with technology. My current role is  Senior Infrastructure Architect  at  Prophecy Networks Ltd  in New Zealand, with a specific interest in networking, systems, open-source, and business management.  I've had a  book published , and I  blog  on topics that interest me.", 
            "title": "Hello world,"
        }, 
        {
            "location": "/whoami/#why-funky-penguin", 
            "text": "My first \"real\" job, out of high-school, was working the IT helpdesk in a typical pre-2000 organization in South Africa. I enjoyed experimenting with Linux, and cut my teeth by replacing the organization's Exchange 5.5 mail platform with a 15-site  qmail-ldap  cluster, with  amavis  virus-scanning.  One of our suppliers asked me to quote to do the same for their organization. With nothing to loose, and half-expecting to be turned down, I quoted a generous fee, and chose a cheeky company name. The supplier immediately accepted my quote, and the name (\" Funky Penguin \") stuck.", 
            "title": "Why Funky Penguin?"
        }, 
        {
            "location": "/whoami/#technical-documentation", 
            "text": "During the same \"real\" job above, I wanted to deploy  jabberd , for internal instant messaging within the organization, and as a means to control the sprawl of ad-hoc instant-messaging among staff, using ICQ, MSN, and Yahoo Messenger.  To get management approval to deploy, I wrote a logger (with web UI) for jabber conversations ( Bandersnatch ), and a  75-page user manual  (in  Docbook XML  for a spunky Russian WinXP jabber client,  JAJC .  Due to my contributions to  phpList , I was approached in 2011 by  Packt Publishing , to  write a book  about using PHPList.", 
            "title": "Technical Documentation"
        }, 
        {
            "location": "/whoami/#contact-me", 
            "text": "Contact me by:   Email ( )  Twitter ( @funkypenguin )  Mastodon ( @davidy@funkypenguin.co.nz )   Or by using the form below:", 
            "title": "Contact Me"
        }, 
        {
            "location": "/ha-docker-swarm/design/", 
            "text": "Design\n\n\nIn the design described below, the \"private cloud\" platform is:\n\n\n\n\nHighly-available\n (\ncan tolerate the failure of a single component\n)\n\n\nScalable\n (\ncan add resource or capacity as required\n)\n\n\nPortable\n (\nrun it on your garage server today, run it in AWS tomorrow\n)\n\n\nSecure\n (\naccess protected with LetsEncrypt certificates\n)\n\n\nAutomated\n (\nrequires minimal care and feeding\n)\n\n\n\n\nDesign Decisions\n\n\nWhere possible, services will be highly available.\n\n\nThis means that:\n\n\n\n\nAt least 3 docker swarm manager nodes are required, to provide fault-tolerance of a single failure.\n\n\nGlusterFS is employed for share filesystem, because it too can be made tolerant of a single failure.\n\n\n\n\nWhere multiple solutions to a requirement exist, preference will be given to the most portable solution.\n\n\nThis means that:\n\n\n\n\nServices are defined using docker-compose v3 YAML syntax\n\n\nServices are portable, meaning a particular stack could be shut down and moved to a new provider with minimal effort.\n\n\n\n\nSecurity\n\n\nUnder this design, the only inbound connections we're permitting to our docker swarm are:\n\n\nNetwork Flows\n\n\n\n\nHTTP (TCP 80) : Redirects to https\n\n\nHTTPS (TCP 443) : Serves individual docker containers via SSL-encrypted reverse proxy\n\n\n\n\nAuthentication\n\n\n\n\nWhere the proxied application provides a trusted level of authentication, or where the application requires public exposure,\n\n\n\n\nHigh availability\n\n\nNormal function\n\n\nAssuming 3 nodes, under normal circumstances the following is illustrated:\n\n\n\n\nAll 3 nodes provide shared storage via GlusterFS, which is provided by a docker container on each node. (i.e., not running in swarm mode)\n\n\nAll 3 nodes participate in the Docker Swarm as managers.\n\n\nThe various containers belonging to the application \"stacks\" deployed within Docker Swarm are automatically distributed amongst the swarm nodes.\n\n\nPersistent storage for the containers is provide via GlusterFS mount.\n\n\nThe \ntraefik\n service (in swarm mode) receives incoming requests (on http and https), and forwards them to individual containers. Traefik knows the containers names because it's able to access the docker socket.\n\n\nAll 3 nodes run keepalived, at different priorities. Since traefik is running as a swarm service and listening on TCP 80/443, requests made to the keepalived VIP and arriving at \nany\n of the swarm nodes will be forwarded to the traefik container (no matter which node it's on), and then onto the target backend.\n\n\n\n\n\n\nNode failure\n\n\nIn the case of a failure (or scheduled maintenance) of one of the nodes, the following is illustrated:\n\n\n\n\nThe failed node no longer participates in GlusterFS, but the remaining nodes provide enough fault-tolerance for the cluster to operate.\n\n\nThe remaining two nodes in Docker Swarm achieve a quorum and agree that the failed node is to be removed.\n\n\nThe (possibly new) leader manager node reschedules the containers known to be running on the failed node, onto other nodes.\n\n\nThe \ntraefik\n service is either restarted or unaffected, and as the backend containers stop/start and change IP, traefik is aware and updates accordingly.\n\n\nThe keepalived VIP continues to function on the remaining nodes, and docker swarm continues to forward any traffic received on TCP 80/443 to the appropriate node.\n\n\n\n\n\n\nNode restore\n\n\nWhen the failed (or upgraded) host is restored to service, the following is illustrated:\n\n\n\n\nGlusterFS regains full redundancy\n\n\nDocker Swarm managers become aware of the recovered node, and will use it for scheduling \nnew\n containers\n\n\nExisting containers which were migrated off the node are not migrated backend\n\n\nKeepalived VIP regains full redundancy\n\n\n\n\n\n\nTotal cluster failure\n\n\nA day after writing this, my environment suffered a fault whereby all 3 VMs were unexpectedly and simultaneously powered off.\n\n\nUpon restore, docker failed to start on one of the VMs due to local disk space issue\n1\n. However, the other two VMs started, established the swarm, mounted their shared storage, and started up all the containers (services) which were managed by the swarm.\n\n\nIn summary, although I suffered an \nunplanned power outage to all of my infrastructure\n, followed by a \nfailure of a third of my hosts\n... \nall my platforms are 100% available with \nabsolutely no manual intervention\n.\n\n\n\n\n\n\n\n\n\n\nSince there's no impact to availability, I can fix (or just reinstall) the failed node whenever convenient.", 
            "title": "Design"
        }, 
        {
            "location": "/ha-docker-swarm/design/#design", 
            "text": "In the design described below, the \"private cloud\" platform is:   Highly-available  ( can tolerate the failure of a single component )  Scalable  ( can add resource or capacity as required )  Portable  ( run it on your garage server today, run it in AWS tomorrow )  Secure  ( access protected with LetsEncrypt certificates )  Automated  ( requires minimal care and feeding )", 
            "title": "Design"
        }, 
        {
            "location": "/ha-docker-swarm/design/#design-decisions", 
            "text": "Where possible, services will be highly available.  This means that:   At least 3 docker swarm manager nodes are required, to provide fault-tolerance of a single failure.  GlusterFS is employed for share filesystem, because it too can be made tolerant of a single failure.   Where multiple solutions to a requirement exist, preference will be given to the most portable solution.  This means that:   Services are defined using docker-compose v3 YAML syntax  Services are portable, meaning a particular stack could be shut down and moved to a new provider with minimal effort.", 
            "title": "Design Decisions"
        }, 
        {
            "location": "/ha-docker-swarm/design/#security", 
            "text": "Under this design, the only inbound connections we're permitting to our docker swarm are:", 
            "title": "Security"
        }, 
        {
            "location": "/ha-docker-swarm/design/#network-flows", 
            "text": "HTTP (TCP 80) : Redirects to https  HTTPS (TCP 443) : Serves individual docker containers via SSL-encrypted reverse proxy", 
            "title": "Network Flows"
        }, 
        {
            "location": "/ha-docker-swarm/design/#authentication", 
            "text": "Where the proxied application provides a trusted level of authentication, or where the application requires public exposure,", 
            "title": "Authentication"
        }, 
        {
            "location": "/ha-docker-swarm/design/#high-availability", 
            "text": "", 
            "title": "High availability"
        }, 
        {
            "location": "/ha-docker-swarm/design/#normal-function", 
            "text": "Assuming 3 nodes, under normal circumstances the following is illustrated:   All 3 nodes provide shared storage via GlusterFS, which is provided by a docker container on each node. (i.e., not running in swarm mode)  All 3 nodes participate in the Docker Swarm as managers.  The various containers belonging to the application \"stacks\" deployed within Docker Swarm are automatically distributed amongst the swarm nodes.  Persistent storage for the containers is provide via GlusterFS mount.  The  traefik  service (in swarm mode) receives incoming requests (on http and https), and forwards them to individual containers. Traefik knows the containers names because it's able to access the docker socket.  All 3 nodes run keepalived, at different priorities. Since traefik is running as a swarm service and listening on TCP 80/443, requests made to the keepalived VIP and arriving at  any  of the swarm nodes will be forwarded to the traefik container (no matter which node it's on), and then onto the target backend.", 
            "title": "Normal function"
        }, 
        {
            "location": "/ha-docker-swarm/design/#node-failure", 
            "text": "In the case of a failure (or scheduled maintenance) of one of the nodes, the following is illustrated:   The failed node no longer participates in GlusterFS, but the remaining nodes provide enough fault-tolerance for the cluster to operate.  The remaining two nodes in Docker Swarm achieve a quorum and agree that the failed node is to be removed.  The (possibly new) leader manager node reschedules the containers known to be running on the failed node, onto other nodes.  The  traefik  service is either restarted or unaffected, and as the backend containers stop/start and change IP, traefik is aware and updates accordingly.  The keepalived VIP continues to function on the remaining nodes, and docker swarm continues to forward any traffic received on TCP 80/443 to the appropriate node.", 
            "title": "Node failure"
        }, 
        {
            "location": "/ha-docker-swarm/design/#node-restore", 
            "text": "When the failed (or upgraded) host is restored to service, the following is illustrated:   GlusterFS regains full redundancy  Docker Swarm managers become aware of the recovered node, and will use it for scheduling  new  containers  Existing containers which were migrated off the node are not migrated backend  Keepalived VIP regains full redundancy", 
            "title": "Node restore"
        }, 
        {
            "location": "/ha-docker-swarm/design/#total-cluster-failure", 
            "text": "A day after writing this, my environment suffered a fault whereby all 3 VMs were unexpectedly and simultaneously powered off.  Upon restore, docker failed to start on one of the VMs due to local disk space issue 1 . However, the other two VMs started, established the swarm, mounted their shared storage, and started up all the containers (services) which were managed by the swarm.  In summary, although I suffered an  unplanned power outage to all of my infrastructure , followed by a  failure of a third of my hosts ...  all my platforms are 100% available with  absolutely no manual intervention .      Since there's no impact to availability, I can fix (or just reinstall) the failed node whenever convenient.", 
            "title": "Total cluster failure"
        }, 
        {
            "location": "/ha-docker-swarm/vms/", 
            "text": "Virtual Machines\n\n\nLet's start building our cloud with virtual machines. You could use bare-metal machines as well, the configuration would be the same. Given that most readers (myself included) will be using virtual infrastructure, from now on I'll be referring strictly to VMs.\n\n\nI chose the \"\nAtomic\n\" CentOS/Fedora image for the VM layer because:\n\n\n\n\nI want less responsibility for maintaining the system, including ensuring regular software updates and reboots. Atomic's idempotent nature means the OS is largely real-only, and updates/rollbacks are \"atomic\" (haha) procedures, which can be easily rolled back if required.\n\n\nFor someone used to administrating servers individually, Atomic is a PITA. You have to employ \ntricky\n \ntricks\n to get it to install in a non-cloud environment. It's not designed for tweaking or customizing beyond what cloud-config is capable of. For my purposes, this is good, because it forces me to change my thinking - to consider every daemon as a container, and every config as code, to be checked in and version-controlled. Atomic forces this thinking on you.\n\n\nI want the design to be as \"portable\" as possible. While I run it on VPSs now, I may want to migrate it to a \"cloud\" provider in the future, and I'll want the most portable, reproducible design.\n\n\n\n\nIngredients\n\n\n\n\nIngredients\n\n\n3 x Virtual Machines, each with:\n\n\n\n\n CentOS/Fedora Atomic\n\n\n At least 1GB RAM\n\n\n At least 20GB disk space (\nbut it'll be tight\n)\n\n\n Connectivity to each other within the same subnet, and on a low-latency link (\ni.e., no WAN links\n)\n\n\n\n\n\n\nPreparation\n\n\nInstall Virtual machines\n\n\n\n\nInstall / launch virtual machines.\n\n\nThe default username on CentOS atomic is \"centos\", and you'll have needed to supply your SSH key during the build process.\n\n\n\n\n\n\nTip\n\n\nIf you're not using a platform with cloud-init support (i.e., you're building a VM manually, not provisioning it through a cloud provider), you'll need to refer to \ntrick #1\n and \n#2\n for a means to override the automated setup, apply a manual password to the CentOS account, and enable SSH password logins.\n\n\n\n\nPrefer docker-latest\n\n\nRun the following on each node to replace the default docker 1.12 with docker 1.13 (\nwhich we need for swarm mode\n):\n\n1\n2\n3\nsystemctl disable docker --now\nsystemctl enable docker-latest --now\nsed -i \n/DOCKERBINARY/s/^#//g\n /etc/sysconfig/docker\n\n\n\n\n\nUpgrade Atomic\n\n\nFinally, apply any Atomic host updates, and reboot, by running: \natomic host upgrade \n systemctl reboot\n.\n\n\nPermit connectivity between VMs\n\n\nBy default, Atomic only permits incoming SSH. We'll want to allow all traffic between our nodes, so add something like this to /etc/sysconfig/iptables:\n\n\n1\n2\n# Allow all inter-node communication\n-A INPUT -s 192.168.31.0/24 -j ACCEPT\n\n\n\n\n\n\nAnd restart iptables with \nsystemctl restart iptables\n\n\nEnable host resolution\n\n\nDepending on your hosting environment, you may have DNS automatically setup for your VMs. If not, it's useful to set up static entries in /etc/hosts for the nodes. For example, I setup the following:\n\n\n1\n2\n3\n192.168.31.11   ds1     ds1.funkypenguin.co.nz\n192.168.31.12   ds2     ds2.funkypenguin.co.nz\n192.168.31.13   ds3     ds3.funkypenguin.co.nz\n\n\n\n\n\n\nServing\n\n\nAfter completing the above, you should have:\n\n\n1\n2\n[X] 3 x fresh atomic instances, at the latest releases,\n    running Docker v1.13 (docker-latest)", 
            "title": "VMs"
        }, 
        {
            "location": "/ha-docker-swarm/vms/#virtual-machines", 
            "text": "Let's start building our cloud with virtual machines. You could use bare-metal machines as well, the configuration would be the same. Given that most readers (myself included) will be using virtual infrastructure, from now on I'll be referring strictly to VMs.  I chose the \" Atomic \" CentOS/Fedora image for the VM layer because:   I want less responsibility for maintaining the system, including ensuring regular software updates and reboots. Atomic's idempotent nature means the OS is largely real-only, and updates/rollbacks are \"atomic\" (haha) procedures, which can be easily rolled back if required.  For someone used to administrating servers individually, Atomic is a PITA. You have to employ  tricky   tricks  to get it to install in a non-cloud environment. It's not designed for tweaking or customizing beyond what cloud-config is capable of. For my purposes, this is good, because it forces me to change my thinking - to consider every daemon as a container, and every config as code, to be checked in and version-controlled. Atomic forces this thinking on you.  I want the design to be as \"portable\" as possible. While I run it on VPSs now, I may want to migrate it to a \"cloud\" provider in the future, and I'll want the most portable, reproducible design.", 
            "title": "Virtual Machines"
        }, 
        {
            "location": "/ha-docker-swarm/vms/#ingredients", 
            "text": "Ingredients  3 x Virtual Machines, each with:    CentOS/Fedora Atomic   At least 1GB RAM   At least 20GB disk space ( but it'll be tight )   Connectivity to each other within the same subnet, and on a low-latency link ( i.e., no WAN links )", 
            "title": "Ingredients"
        }, 
        {
            "location": "/ha-docker-swarm/vms/#preparation", 
            "text": "", 
            "title": "Preparation"
        }, 
        {
            "location": "/ha-docker-swarm/vms/#install-virtual-machines", 
            "text": "Install / launch virtual machines.  The default username on CentOS atomic is \"centos\", and you'll have needed to supply your SSH key during the build process.    Tip  If you're not using a platform with cloud-init support (i.e., you're building a VM manually, not provisioning it through a cloud provider), you'll need to refer to  trick #1  and  #2  for a means to override the automated setup, apply a manual password to the CentOS account, and enable SSH password logins.", 
            "title": "Install Virtual machines"
        }, 
        {
            "location": "/ha-docker-swarm/vms/#prefer-docker-latest", 
            "text": "Run the following on each node to replace the default docker 1.12 with docker 1.13 ( which we need for swarm mode ): 1\n2\n3 systemctl disable docker --now\nsystemctl enable docker-latest --now\nsed -i  /DOCKERBINARY/s/^#//g  /etc/sysconfig/docker", 
            "title": "Prefer docker-latest"
        }, 
        {
            "location": "/ha-docker-swarm/vms/#upgrade-atomic", 
            "text": "Finally, apply any Atomic host updates, and reboot, by running:  atomic host upgrade   systemctl reboot .", 
            "title": "Upgrade Atomic"
        }, 
        {
            "location": "/ha-docker-swarm/vms/#permit-connectivity-between-vms", 
            "text": "By default, Atomic only permits incoming SSH. We'll want to allow all traffic between our nodes, so add something like this to /etc/sysconfig/iptables:  1\n2 # Allow all inter-node communication\n-A INPUT -s 192.168.31.0/24 -j ACCEPT   And restart iptables with  systemctl restart iptables", 
            "title": "Permit connectivity between VMs"
        }, 
        {
            "location": "/ha-docker-swarm/vms/#enable-host-resolution", 
            "text": "Depending on your hosting environment, you may have DNS automatically setup for your VMs. If not, it's useful to set up static entries in /etc/hosts for the nodes. For example, I setup the following:  1\n2\n3 192.168.31.11   ds1     ds1.funkypenguin.co.nz\n192.168.31.12   ds2     ds2.funkypenguin.co.nz\n192.168.31.13   ds3     ds3.funkypenguin.co.nz", 
            "title": "Enable host resolution"
        }, 
        {
            "location": "/ha-docker-swarm/vms/#serving", 
            "text": "After completing the above, you should have:  1\n2 [X] 3 x fresh atomic instances, at the latest releases,\n    running Docker v1.13 (docker-latest)", 
            "title": "Serving"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/", 
            "text": "Shared Storage (Ceph)\n\n\nWhile Docker Swarm is great for keeping containers running (\nand restarting those that fail\n), it does nothing for persistent storage. This means if you actually want your containers to keep any data persistent across restarts (\nhint: you do!\n), you need to provide shared storage to every docker node.\n\n\nDesign\n\n\nWhy not GlusterFS?\n\n\nI originally provided shared storage to my nodes using GlusterFS (see the next recipe for details), but found it difficult to deal with because:\n\n\n\n\nGlusterFS requires (n) \"bricks\", where (n) \nhas\n to be a multiple of your replica count. I.e., if you want 2 copies of everything on shared storage (the minimum to provide redundancy), you \nmust\n have either 2, 4, 6 (etc..) bricks. The HA swarm design calls for minimum of 3 nodes, and so under GlusterFS, my third node can't participate in shared storage at all, unless I start doubling up on bricks-per-node (which then impacts redundancy)\n\n\nGlusterFS turns out to be a giant PITA when you want to restore a failed node. There are at \nleast 14 steps to follow\n to replace a brick.\n\n\nI'm pretty sure I messed up the 14-step process above anyway. My replaced brick synced with my \"original\" brick, but produced errors when querying status via the CLI, and hogged 100% of 1 CPU on the replaced node. Inexperienced with GlusterFS, and unable to diagnose the fault, I switched to a Ceph cluster instead.\n\n\n\n\nWhy Ceph?\n\n\n\n\nI'm more familiar with Ceph - I use it in the OpenStack designs I manage\n\n\nReplacing a failed node is \neasy\n, provided you can put up with the I/O load of rebalancing OSDs after the replacement.\n\n\nCentOS Atomic includes the ceph client in the OS, so while the Ceph OSD/Mon/MSD are running under containers, I can keep an eye (and later, automatically monitor) the status of Ceph from the base OS.\n\n\n\n\nIngredients\n\n\n\n\nIngredients\n\n\n3 x Virtual Machines (configured earlier), each with:\n\n\n\n\n CentOS/Fedora Atomic\n\n\n At least 1GB RAM\n\n\n At least 20GB disk space (\nbut it'll be tight\n)\n\n\n Connectivity to each other within the same subnet, and on a low-latency link (\ni.e., no WAN links\n)\n\n\n A second disk dedicated to the Ceph OSD\n\n\n\n\n\n\nPreparation\n\n\nSELinux\n\n\nSince our Ceph components will be containerized, we need to ensure the SELinux context on the base OS's ceph files is set correctly:\n\n\n1\n2\nchcon -Rt svirt_sandbox_file_t /etc/ceph\nchcon -Rt svirt_sandbox_file_t /var/lib/ceph\n\n\n\n\n\n\nSetup Monitors\n\n\nPick a node, and run the following to stand up the first Ceph mon. Be sure to replace the values for \nMON_IP\n and \nCEPH_PUBLIC_NETWORK\n to those specific to your deployment:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\ndocker run -d --net=host \\\n--restart always \\\n-v /etc/ceph:/etc/ceph \\\n-v /var/lib/ceph/:/var/lib/ceph/ \\\n-e MON_IP=192.168.31.11 \\\n-e CEPH_PUBLIC_NETWORK=192.168.31.0/24 \\\n--name=\nceph-mon\n \\\nceph/daemon mon\n\n\n\n\n\n\nNow \ncopy\n the contents of /etc/ceph on this first node to the remaining nodes, and \nthen\n run the docker command above (\ncustomizing MON_IP as you go\n) on each remaining node. You'll end up with a cluster with 3 monitors (odd number is required for quorum, same as Docker Swarm), and no OSDs (yet)\n\n\nSetup OSDs\n\n\nSince we have a OSD-less mon-only cluster currently, prepare for OSD creation by dumping the auth credentials for the OSDs into the appropriate location on the base OS:\n\n\n1\n2\nceph auth get client.bootstrap-osd -o \\\n/var/lib/ceph/bootstrap-osd/ceph.keyring\n\n\n\n\n\n\nOn each node, you need a dedicated disk for the OSD. In the example below, I used \n/dev/vdd\n (the entire disk, no partitions) for the OSD.\n\n\nRun the following command on every node:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\ndocker run -d --net=host \\\n--privileged=true \\\n--pid=host \\\n-v /etc/ceph:/etc/ceph \\\n-v /var/lib/ceph/:/var/lib/ceph/ \\\n-v /dev/:/dev/ \\\n-e OSD_DEVICE=/dev/vdd \\\n-e OSD_TYPE=disk \\\n--name=\nceph-osd\n \\\n--restart=always \\\nceph/daemon osd\n\n\n\n\n\n\nWatch the output by running \ndocker logs ceph-osd -f\n, and confirm success.\n\n\n\n\nZapping the device\n\n\nThe Ceph OSD container will refuse to destroy a partition containing existing data, so it may be necessary to \"zap\" the target disk, using:\n\n1\n2\n3\n4\ndocker run -d --privileged=true \\\n-v /dev/:/dev/ \\\n-e OSD_DEVICE=/dev/sdd \\\nceph/daemon zap_device\n\n\n\n\n\n\n\nSetup MDSs\n\n\nIn order to mount our ceph pools as filesystems, we'll need Ceph MDS(s). Run the following on each node:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\ndocker run -d --net=host \\\n--name ceph-mds \\\n--restart always \\\n-v /var/lib/ceph/:/var/lib/ceph/ \\\n-v /etc/ceph:/etc/ceph \\\n-e CEPHFS_CREATE=1 \\\n-e CEPHFS_DATA_POOL_PG=256 \\\n-e CEPHFS_METADATA_POOL_PG=256 \\\nceph/daemon mds\n\n\n\n\n\n\nApply tweaks\n\n\nThe ceph container seems to configure a pool default of 3 replicas (3 copies of each block are retained), which is one too many for our cluster (we are only protecting against the failure of a single node).\n\n\nRun the following on any node to reduce the size of the pool to 2 replicas:\n\n\n1\n2\nceph osd pool set cephfs_data size 2\nceph osd pool set cephfs_metadata size 2\n\n\n\n\n\n\nDisabled \"scrubbing\" (which can be IO-intensive, and is unnecessary on a VM) with:\n\n\n1\n2\nceph osd set noscrub\nceph osd set nodeep-scrub\n\n\n\n\n\n\nCreate credentials for swarm\n\n\nIn order to mount the ceph volume onto our base host, we need to provide cephx authentication credentials.\n\n\nOn \none\n node, create a client for the docker swarm:\n\n\n1\n2\nceph auth get-or-create client.dockerswarm osd \\\n\nallow rw\n mon \nallow r\n mds \nallow\n \n /etc/ceph/keyring.dockerswarm\n\n\n\n\n\n\nGrab the secret associated with the new user (you'll need this for the /etc/fstab entry below) by running:\n\n\n1\nceph-authtool /etc/ceph/keyring.dockerswarm -p -n client.dockerswarm\n\n\n\n\n\n\nMount MDS volume\n\n\nOn each noie, create a mountpoint for the data, by running \nmkdir /var/data\n, add an entry to fstab to ensure the volume is auto-mounted on boot, and ensure the volume is actually \nmounted\n if there's a network / boot delay getting access to the gluster volume:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nmkdir /var/data\n\nMYHOST=`hostname -s`\necho -e \n\n# Mount cephfs volume \\n\n$MYHOST:6789:/      /var/data/      ceph      \\\nname=dockerswarm\\\n,secret=\nYOUR SECRET HERE\n\\\n,noatime,_netdev,context=system_u:object_r:svirt_sandbox_file_t:s0\\\n0 2\n \n /etc/fstab\nmount -a\n\n\n\n\n\n\nInstall docker-volume plugin\n\n\nUpstream bug for docker-latest reported at \nhttps://bugs.centos.org/view.php?id=13609\n\n\nAnd the alpine fault:\n\nhttps://github.com/gliderlabs/docker-alpine/issues/317\n\n\nServing\n\n\nAfter completing the above, you should have:\n\n\n1\n2\n[X] Persistent storage available to every node\n[X] Resiliency in the event of the failure of a single node\n\n\n\n\n\n\nChef's Notes\n\n\nFuture enhancements to this recipe include:\n\n\n\n\nRather than pasting a secret key into /etc/fstab (which feels wrong), I'd prefer to be able to set \"secretfile\" in /etc/fstab (which just points ceph.mount to a file containing the secret), but under the current CentOS Atomic, we're stuck with \"secret\", per \nhttps://bugzilla.redhat.com/show_bug.cgi?id=1030402", 
            "title": "Shared Storage (Ceph)"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#shared-storage-ceph", 
            "text": "While Docker Swarm is great for keeping containers running ( and restarting those that fail ), it does nothing for persistent storage. This means if you actually want your containers to keep any data persistent across restarts ( hint: you do! ), you need to provide shared storage to every docker node.", 
            "title": "Shared Storage (Ceph)"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#design", 
            "text": "", 
            "title": "Design"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#why-not-glusterfs", 
            "text": "I originally provided shared storage to my nodes using GlusterFS (see the next recipe for details), but found it difficult to deal with because:   GlusterFS requires (n) \"bricks\", where (n)  has  to be a multiple of your replica count. I.e., if you want 2 copies of everything on shared storage (the minimum to provide redundancy), you  must  have either 2, 4, 6 (etc..) bricks. The HA swarm design calls for minimum of 3 nodes, and so under GlusterFS, my third node can't participate in shared storage at all, unless I start doubling up on bricks-per-node (which then impacts redundancy)  GlusterFS turns out to be a giant PITA when you want to restore a failed node. There are at  least 14 steps to follow  to replace a brick.  I'm pretty sure I messed up the 14-step process above anyway. My replaced brick synced with my \"original\" brick, but produced errors when querying status via the CLI, and hogged 100% of 1 CPU on the replaced node. Inexperienced with GlusterFS, and unable to diagnose the fault, I switched to a Ceph cluster instead.", 
            "title": "Why not GlusterFS?"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#why-ceph", 
            "text": "I'm more familiar with Ceph - I use it in the OpenStack designs I manage  Replacing a failed node is  easy , provided you can put up with the I/O load of rebalancing OSDs after the replacement.  CentOS Atomic includes the ceph client in the OS, so while the Ceph OSD/Mon/MSD are running under containers, I can keep an eye (and later, automatically monitor) the status of Ceph from the base OS.", 
            "title": "Why Ceph?"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#ingredients", 
            "text": "Ingredients  3 x Virtual Machines (configured earlier), each with:    CentOS/Fedora Atomic   At least 1GB RAM   At least 20GB disk space ( but it'll be tight )   Connectivity to each other within the same subnet, and on a low-latency link ( i.e., no WAN links )   A second disk dedicated to the Ceph OSD", 
            "title": "Ingredients"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#preparation", 
            "text": "", 
            "title": "Preparation"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#selinux", 
            "text": "Since our Ceph components will be containerized, we need to ensure the SELinux context on the base OS's ceph files is set correctly:  1\n2 chcon -Rt svirt_sandbox_file_t /etc/ceph\nchcon -Rt svirt_sandbox_file_t /var/lib/ceph", 
            "title": "SELinux"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#setup-monitors", 
            "text": "Pick a node, and run the following to stand up the first Ceph mon. Be sure to replace the values for  MON_IP  and  CEPH_PUBLIC_NETWORK  to those specific to your deployment:  1\n2\n3\n4\n5\n6\n7\n8 docker run -d --net=host \\\n--restart always \\\n-v /etc/ceph:/etc/ceph \\\n-v /var/lib/ceph/:/var/lib/ceph/ \\\n-e MON_IP=192.168.31.11 \\\n-e CEPH_PUBLIC_NETWORK=192.168.31.0/24 \\\n--name= ceph-mon  \\\nceph/daemon mon   Now  copy  the contents of /etc/ceph on this first node to the remaining nodes, and  then  run the docker command above ( customizing MON_IP as you go ) on each remaining node. You'll end up with a cluster with 3 monitors (odd number is required for quorum, same as Docker Swarm), and no OSDs (yet)", 
            "title": "Setup Monitors"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#setup-osds", 
            "text": "Since we have a OSD-less mon-only cluster currently, prepare for OSD creation by dumping the auth credentials for the OSDs into the appropriate location on the base OS:  1\n2 ceph auth get client.bootstrap-osd -o \\\n/var/lib/ceph/bootstrap-osd/ceph.keyring   On each node, you need a dedicated disk for the OSD. In the example below, I used  /dev/vdd  (the entire disk, no partitions) for the OSD.  Run the following command on every node:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 docker run -d --net=host \\\n--privileged=true \\\n--pid=host \\\n-v /etc/ceph:/etc/ceph \\\n-v /var/lib/ceph/:/var/lib/ceph/ \\\n-v /dev/:/dev/ \\\n-e OSD_DEVICE=/dev/vdd \\\n-e OSD_TYPE=disk \\\n--name= ceph-osd  \\\n--restart=always \\\nceph/daemon osd   Watch the output by running  docker logs ceph-osd -f , and confirm success.   Zapping the device  The Ceph OSD container will refuse to destroy a partition containing existing data, so it may be necessary to \"zap\" the target disk, using: 1\n2\n3\n4 docker run -d --privileged=true \\\n-v /dev/:/dev/ \\\n-e OSD_DEVICE=/dev/sdd \\\nceph/daemon zap_device", 
            "title": "Setup OSDs"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#setup-mdss", 
            "text": "In order to mount our ceph pools as filesystems, we'll need Ceph MDS(s). Run the following on each node:  1\n2\n3\n4\n5\n6\n7\n8\n9 docker run -d --net=host \\\n--name ceph-mds \\\n--restart always \\\n-v /var/lib/ceph/:/var/lib/ceph/ \\\n-v /etc/ceph:/etc/ceph \\\n-e CEPHFS_CREATE=1 \\\n-e CEPHFS_DATA_POOL_PG=256 \\\n-e CEPHFS_METADATA_POOL_PG=256 \\\nceph/daemon mds", 
            "title": "Setup MDSs"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#apply-tweaks", 
            "text": "The ceph container seems to configure a pool default of 3 replicas (3 copies of each block are retained), which is one too many for our cluster (we are only protecting against the failure of a single node).  Run the following on any node to reduce the size of the pool to 2 replicas:  1\n2 ceph osd pool set cephfs_data size 2\nceph osd pool set cephfs_metadata size 2   Disabled \"scrubbing\" (which can be IO-intensive, and is unnecessary on a VM) with:  1\n2 ceph osd set noscrub\nceph osd set nodeep-scrub", 
            "title": "Apply tweaks"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#create-credentials-for-swarm", 
            "text": "In order to mount the ceph volume onto our base host, we need to provide cephx authentication credentials.  On  one  node, create a client for the docker swarm:  1\n2 ceph auth get-or-create client.dockerswarm osd \\ allow rw  mon  allow r  mds  allow    /etc/ceph/keyring.dockerswarm   Grab the secret associated with the new user (you'll need this for the /etc/fstab entry below) by running:  1 ceph-authtool /etc/ceph/keyring.dockerswarm -p -n client.dockerswarm", 
            "title": "Create credentials for swarm"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#mount-mds-volume", 
            "text": "On each noie, create a mountpoint for the data, by running  mkdir /var/data , add an entry to fstab to ensure the volume is auto-mounted on boot, and ensure the volume is actually  mounted  if there's a network / boot delay getting access to the gluster volume:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 mkdir /var/data\n\nMYHOST=`hostname -s`\necho -e  \n# Mount cephfs volume \\n\n$MYHOST:6789:/      /var/data/      ceph      \\\nname=dockerswarm\\\n,secret= YOUR SECRET HERE \\\n,noatime,_netdev,context=system_u:object_r:svirt_sandbox_file_t:s0\\\n0 2    /etc/fstab\nmount -a", 
            "title": "Mount MDS volume"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#install-docker-volume-plugin", 
            "text": "Upstream bug for docker-latest reported at  https://bugs.centos.org/view.php?id=13609  And the alpine fault: https://github.com/gliderlabs/docker-alpine/issues/317", 
            "title": "Install docker-volume plugin"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#serving", 
            "text": "After completing the above, you should have:  1\n2 [X] Persistent storage available to every node\n[X] Resiliency in the event of the failure of a single node", 
            "title": "Serving"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-ceph/#chefs-notes", 
            "text": "Future enhancements to this recipe include:   Rather than pasting a secret key into /etc/fstab (which feels wrong), I'd prefer to be able to set \"secretfile\" in /etc/fstab (which just points ceph.mount to a file containing the secret), but under the current CentOS Atomic, we're stuck with \"secret\", per  https://bugzilla.redhat.com/show_bug.cgi?id=1030402", 
            "title": "Chef's Notes"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/", 
            "text": "Shared Storage (GlusterFS)\n\n\nWhile Docker Swarm is great for keeping containers running (\nand restarting those that fail\n), it does nothing for persistent storage. This means if you actually want your containers to keep any data persistent across restarts (\nhint: you do!\n), you need to provide shared storage to every docker node.\n\n\nDesign\n\n\nWhy GlusterFS?\n\n\nThis GlusterFS recipe was my original design for shared storage, but I \nfound it to be flawed\n, and I replaced it with a \ndesign which employs Ceph instead\n. This recipe is an alternate to the Ceph design, if you happen to prefer GlusterFS.\n\n\nIngredients\n\n\n\n\nIngredients\n\n\n3 x Virtual Machines (configured earlier), each with:\n\n\n\n\n CentOS/Fedora Atomic\n\n\n At least 1GB RAM\n\n\n At least 20GB disk space (\nbut it'll be tight\n)\n\n\n Connectivity to each other within the same subnet, and on a low-latency link (\ni.e., no WAN links\n)\n\n\n A second disk, or adequate space on the primary disk for a dedicated data partition\n\n\n\n\n\n\nPreparation\n\n\nCreate Gluster \"bricks\"\n\n\nTo build our Gluster volume, we need 2 out of the 3 VMs to provide one \"brick\". The bricks will be used to create the replicated volume. Assuming a replica count of 2 (\ni.e., 2 copies of the data are kept in gluster\n), our total number of bricks must be divisible by our replica count. (\nI.e., you can't have 3 bricks if you want 2 replicas. You can have 4 though - We have to have minimum 3 swarm manager nodes for fault-tolerance, but only 2 of those nodes need to run as gluster servers.\n)\n\n\nOn each host, run a variation following to create your bricks, adjusted for the path to your disk.\n\n\n\n\nThe example below assumes /dev/vdb is dedicated to the gluster volume\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n(\necho o # Create a new empty DOS partition table\necho n # Add a new partition\necho p # Primary partition\necho 1 # Partition number\necho   # First sector (Accept default: 1)\necho   # Last sector (Accept default: varies)\necho w # Write changes\n) | sudo fdisk /dev/vdb\n\nmkfs.xfs -i size=512 /dev/vdb1\nmkdir -p /var/no-direct-write-here/brick1\necho \n \n /etc/fstab \n /etc/fstab\necho \n# Mount /dev/vdb1 so that it can be used as a glusterfs volume\n \n /etc/fstab\necho \n/dev/vdb1 /var/no-direct-write-here/brick1 xfs defaults 1 2\n \n /etc/fstab\nmount -a \n mount\n\n\n\n\n\n\n\n\nDon't provision all your LVM space\n\n\nAtomic uses LVM to store docker data, and \nautomatically grows\n Docker's volumes as requried. If you commit all your free LVM space to your brick, you'll quickly find (as I did) that docker will start to fail with error messages about insufficient space. If you're going to slice off a portion of your LVM space in /dev/atomicos, make sure you leave enough space for Docker storage, where \"enough\" depends on how much you plan to pull images, make volumes, etc. I ate through 20GB very quickly doing development, so I ended up provisioning 50GB for atomic alone, with a separate volume for the brick.\n\n\n\n\nCreate glusterfs container\n\n\nAtomic doesn't include the Gluster server components.  This means we'll have to run glusterd from within a container, with privileged access to the host. Although convoluted, I've come to prefer this design since it once again makes the OS \"disposable\", moving all the config into containers and code.\n\n\nRun the following on each host:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\ndocker run \\\n   -h glusterfs-server \\\n   -v /etc/glusterfs:/etc/glusterfs:z \\\n   -v /var/lib/glusterd:/var/lib/glusterd:z \\\n   -v /var/log/glusterfs:/var/log/glusterfs:z \\\n   -v /sys/fs/cgroup:/sys/fs/cgroup:ro \\\n   -v /var/no-direct-write-here/brick1:/var/no-direct-write-here/brick1 \\\n   -d --privileged=true --net=host \\\n   --restart=always \\\n   --name=\nglusterfs-server\n \\\n   gluster/gluster-centos\n\n\n\n\n\nCreate trusted pool\n\n\nOn a single node (doesn't matter which), run \ndocker exec -it glusterfs-server bash\n to launch a shell inside the container.\n\n\nFrom the node, run\n\ngluster peer probe \nother host\n\n\nExample output:\n\n1\n2\n3\n[root@glusterfs-server /]# gluster peer probe ds1\npeer probe: success.\n[root@glusterfs-server /]#\n\n\n\n\n\nRun \ngluster peer status\n on both nodes to confirm that they're properly connected to each other:\n\n\nExample output:\n\n1\n2\n3\n4\n5\n6\n7\n[root@glusterfs-server /]# gluster peer status\nNumber of Peers: 1\n\nHostname: ds3\nUuid: 3e115ba9-6a4f-48dd-87d7-e843170ff499\nState: Peer in Cluster (Connected)\n[root@glusterfs-server /]#\n\n\n\n\n\nCreate gluster volume\n\n\nNow we create a \nreplicated volume\n out of our individual \"bricks\".\n\n\nCreate the gluster volume by running\n\n1\n2\n3\ngluster volume create gv0 replica 2 \\\n server1:/var/no-direct-write-here/brick1 \\\n server2:/var/no-direct-write-here/brick1\n\n\n\n\n\nExample output:\n\n1\n2\n3\n[root@glusterfs-server /]# gluster volume create gv0 replica 2 ds1:/var/no-direct-write-here/brick1/gv0  ds3:/var/no-direct-write-here/brick1/gv0\nvolume create: gv0: success: please start the volume to access data\n[root@glusterfs-server /]#\n\n\n\n\n\nStart the volume by running \ngluster volume start gv0\n\n\n1\n2\n3\n[root@glusterfs-server /]# gluster volume start gv0\nvolume start: gv0: success\n[root@glusterfs-server /]#\n\n\n\n\n\n\nThe volume is only present on the host you're shelled into though. To add the other hosts to the volume, run \ngluster peer probe \nservername\n. Don't probe host from itself.\n\n\nFrom one other host, run \ndocker exec -it glusterfs-server bash\n to shell into the gluster-server container, and run \ngluster peer probe \noriginal server name\n to update the name of the host which started the volume.\n\n\nMount gluster volume\n\n\nOn the host (i.e., outside of the container - type \nexit\n if you're still shelled in), create a mountpoint for the data, by running \nmkdir /var/data\n, add an entry to fstab to ensure the volume is auto-mounted on boot, and ensure the volume is actually \nmounted\n if there's a network / boot delay getting access to the gluster volume:\n\n\n1\n2\n3\n4\n5\n6\nmkdir /var/data\nMYHOST=`hostname -s`\necho \n \n /etc/fstab \n /etc/fstab\necho \n# Mount glusterfs volume\n \n /etc/fstab\necho \n$MYHOST:/gv0                /var/data      glusterfs       defaults,_netdev,context=\nsystem_u:object_r:svirt_sandbox_file_t:s0\n  0  0\n  \n /etc/fstab\nmount -a\n\n\n\n\n\n\nFor some reason, my nodes won't auto-mount this volume on boot. I even tried the trickery below, but they stubbornly refuse to automount.\n\n1\n2\n3\necho -e \n\\n\\n# Give GlusterFS 10s to start before \\\nmounting\\nsleep 10s \n mount -a\n \n /etc/rc.local\nsystemctl enable rc-local.service\n\n\n\n\n\nFor non-gluster nodes, you'll need to replace $MYHOST above with the name of one of the gluster hosts (I haven't worked out how to make this fully HA yet)\n\n\nServing\n\n\nAfter completing the above, you should have:\n\n\n1\n2\n[X] Persistent storage available to every node\n[X] Resiliency in the event of the failure of a single (gluster) node\n\n\n\n\n\n\nChef's Notes\n\n\nFuture enhancements to this recipe include:\n\n\n\n\nMigration of shared storage from GlusterFS to Ceph ()\n#2\n)\n\n\nCorrect the fact that volumes don't automount on boot (\n#3\n)", 
            "title": "Shared Storage (GlusterFS)"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/#shared-storage-glusterfs", 
            "text": "While Docker Swarm is great for keeping containers running ( and restarting those that fail ), it does nothing for persistent storage. This means if you actually want your containers to keep any data persistent across restarts ( hint: you do! ), you need to provide shared storage to every docker node.", 
            "title": "Shared Storage (GlusterFS)"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/#design", 
            "text": "", 
            "title": "Design"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/#why-glusterfs", 
            "text": "This GlusterFS recipe was my original design for shared storage, but I  found it to be flawed , and I replaced it with a  design which employs Ceph instead . This recipe is an alternate to the Ceph design, if you happen to prefer GlusterFS.", 
            "title": "Why GlusterFS?"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/#ingredients", 
            "text": "Ingredients  3 x Virtual Machines (configured earlier), each with:    CentOS/Fedora Atomic   At least 1GB RAM   At least 20GB disk space ( but it'll be tight )   Connectivity to each other within the same subnet, and on a low-latency link ( i.e., no WAN links )   A second disk, or adequate space on the primary disk for a dedicated data partition", 
            "title": "Ingredients"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/#preparation", 
            "text": "", 
            "title": "Preparation"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/#create-gluster-bricks", 
            "text": "To build our Gluster volume, we need 2 out of the 3 VMs to provide one \"brick\". The bricks will be used to create the replicated volume. Assuming a replica count of 2 ( i.e., 2 copies of the data are kept in gluster ), our total number of bricks must be divisible by our replica count. ( I.e., you can't have 3 bricks if you want 2 replicas. You can have 4 though - We have to have minimum 3 swarm manager nodes for fault-tolerance, but only 2 of those nodes need to run as gluster servers. )  On each host, run a variation following to create your bricks, adjusted for the path to your disk.   The example below assumes /dev/vdb is dedicated to the gluster volume    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 (\necho o # Create a new empty DOS partition table\necho n # Add a new partition\necho p # Primary partition\necho 1 # Partition number\necho   # First sector (Accept default: 1)\necho   # Last sector (Accept default: varies)\necho w # Write changes\n) | sudo fdisk /dev/vdb\n\nmkfs.xfs -i size=512 /dev/vdb1\nmkdir -p /var/no-direct-write-here/brick1\necho     /etc/fstab   /etc/fstab\necho  # Mount /dev/vdb1 so that it can be used as a glusterfs volume    /etc/fstab\necho  /dev/vdb1 /var/no-direct-write-here/brick1 xfs defaults 1 2    /etc/fstab\nmount -a   mount    Don't provision all your LVM space  Atomic uses LVM to store docker data, and  automatically grows  Docker's volumes as requried. If you commit all your free LVM space to your brick, you'll quickly find (as I did) that docker will start to fail with error messages about insufficient space. If you're going to slice off a portion of your LVM space in /dev/atomicos, make sure you leave enough space for Docker storage, where \"enough\" depends on how much you plan to pull images, make volumes, etc. I ate through 20GB very quickly doing development, so I ended up provisioning 50GB for atomic alone, with a separate volume for the brick.", 
            "title": "Create Gluster \"bricks\""
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/#create-glusterfs-container", 
            "text": "Atomic doesn't include the Gluster server components.  This means we'll have to run glusterd from within a container, with privileged access to the host. Although convoluted, I've come to prefer this design since it once again makes the OS \"disposable\", moving all the config into containers and code.  Run the following on each host:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 docker run \\\n   -h glusterfs-server \\\n   -v /etc/glusterfs:/etc/glusterfs:z \\\n   -v /var/lib/glusterd:/var/lib/glusterd:z \\\n   -v /var/log/glusterfs:/var/log/glusterfs:z \\\n   -v /sys/fs/cgroup:/sys/fs/cgroup:ro \\\n   -v /var/no-direct-write-here/brick1:/var/no-direct-write-here/brick1 \\\n   -d --privileged=true --net=host \\\n   --restart=always \\\n   --name= glusterfs-server  \\\n   gluster/gluster-centos", 
            "title": "Create glusterfs container"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/#create-trusted-pool", 
            "text": "On a single node (doesn't matter which), run  docker exec -it glusterfs-server bash  to launch a shell inside the container.  From the node, run gluster peer probe  other host  Example output: 1\n2\n3 [root@glusterfs-server /]# gluster peer probe ds1\npeer probe: success.\n[root@glusterfs-server /]#   Run  gluster peer status  on both nodes to confirm that they're properly connected to each other:  Example output: 1\n2\n3\n4\n5\n6\n7 [root@glusterfs-server /]# gluster peer status\nNumber of Peers: 1\n\nHostname: ds3\nUuid: 3e115ba9-6a4f-48dd-87d7-e843170ff499\nState: Peer in Cluster (Connected)\n[root@glusterfs-server /]#", 
            "title": "Create trusted pool"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/#create-gluster-volume", 
            "text": "Now we create a  replicated volume  out of our individual \"bricks\".  Create the gluster volume by running 1\n2\n3 gluster volume create gv0 replica 2 \\\n server1:/var/no-direct-write-here/brick1 \\\n server2:/var/no-direct-write-here/brick1   Example output: 1\n2\n3 [root@glusterfs-server /]# gluster volume create gv0 replica 2 ds1:/var/no-direct-write-here/brick1/gv0  ds3:/var/no-direct-write-here/brick1/gv0\nvolume create: gv0: success: please start the volume to access data\n[root@glusterfs-server /]#   Start the volume by running  gluster volume start gv0  1\n2\n3 [root@glusterfs-server /]# gluster volume start gv0\nvolume start: gv0: success\n[root@glusterfs-server /]#   The volume is only present on the host you're shelled into though. To add the other hosts to the volume, run  gluster peer probe  servername . Don't probe host from itself.  From one other host, run  docker exec -it glusterfs-server bash  to shell into the gluster-server container, and run  gluster peer probe  original server name  to update the name of the host which started the volume.", 
            "title": "Create gluster volume"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/#mount-gluster-volume", 
            "text": "On the host (i.e., outside of the container - type  exit  if you're still shelled in), create a mountpoint for the data, by running  mkdir /var/data , add an entry to fstab to ensure the volume is auto-mounted on boot, and ensure the volume is actually  mounted  if there's a network / boot delay getting access to the gluster volume:  1\n2\n3\n4\n5\n6 mkdir /var/data\nMYHOST=`hostname -s`\necho     /etc/fstab   /etc/fstab\necho  # Mount glusterfs volume    /etc/fstab\necho  $MYHOST:/gv0                /var/data      glusterfs       defaults,_netdev,context= system_u:object_r:svirt_sandbox_file_t:s0   0  0     /etc/fstab\nmount -a   For some reason, my nodes won't auto-mount this volume on boot. I even tried the trickery below, but they stubbornly refuse to automount. 1\n2\n3 echo -e  \\n\\n# Give GlusterFS 10s to start before \\\nmounting\\nsleep 10s   mount -a    /etc/rc.local\nsystemctl enable rc-local.service   For non-gluster nodes, you'll need to replace $MYHOST above with the name of one of the gluster hosts (I haven't worked out how to make this fully HA yet)", 
            "title": "Mount gluster volume"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/#serving", 
            "text": "After completing the above, you should have:  1\n2 [X] Persistent storage available to every node\n[X] Resiliency in the event of the failure of a single (gluster) node", 
            "title": "Serving"
        }, 
        {
            "location": "/ha-docker-swarm/shared-storage-gluster/#chefs-notes", 
            "text": "Future enhancements to this recipe include:   Migration of shared storage from GlusterFS to Ceph () #2 )  Correct the fact that volumes don't automount on boot ( #3 )", 
            "title": "Chef's Notes"
        }, 
        {
            "location": "/ha-docker-swarm/keepalived/", 
            "text": "Keepalived\n\n\nWhile having a self-healing, scalable docker swarm is great for availability and scalability, none of that is any good if nobody can connect to your cluster.\n\n\nIn order to provide seamless external access to clustered resources, regardless of which node they're on and tolerant of node failure, you need to present a single IP to the world for external access.\n\n\nNormally this is done using a HA loadbalancer, but since Docker Swarm aready provides the load-balancing capabilities (routing mesh), all we need for seamless HA is a virtual IP which will be provided by more than one docker node.\n\n\nThis is accomplished with the use of keepalived on at least two nodes.\n\n\nIngredients\n\n\n1\n2\n3\n4\n5\n6\nAlready deployed:\n[X] At least 2 x CentOS/Fedora Atomic VMs\n[X] low-latency link (i.e., no WAN links)\n\nNew:\n[ ] 3 x IPv4 addresses (one for each node and one for the virtual IP)\n\n\n\n\n\n\nPreparation\n\n\nEnable IPVS module\n\n\nOn all nodes which will participate in keepalived, we need the \"ip_vs\" kernel module, in order to permit serivces to bind to non-local interface addresses.\n\n\nSet this up once for both the primary and secondary nodes, by running:\n\n\n1\n2\necho \nmodprobe ip_vs\n \n /etc/rc.local\nmodprobe ip_vs\n\n\n\n\n\n\nSetup nodes\n\n\nAssuming your IPs are as follows:\n\n\n\n\n192.168.4.1 : Primary\n\n\n192.168.4.2 : Secondary\n\n\n192.168.4.3 : Virtual\n\n\n\n\nRun the following on the primary\n\n1\n2\n3\n4\n5\n6\ndocker run -d --name keepalived --restart=always \\\n  --cap-add=NET_ADMIN --net=host \\\n  -e KEEPALIVED_UNICAST_PEERS=\n#PYTHON2BASH:[\n192.168.4.1\n, \n192.168.4.2\n]\n \\\n  -e KEEPALIVED_VIRTUAL_IPS=192.168.4.3 \\\n  -e KEEPALIVED_PRIORITY=200 \\\n  osixia/keepalived:1.3.5\n\n\n\n\n\nAnd on the secondary:\n\n1\n2\n3\n4\n5\n6\ndocker run -d --name keepalived --restart=always \\\n  --cap-add=NET_ADMIN --net=host \\\n  -e KEEPALIVED_UNICAST_PEERS=\n#PYTHON2BASH:[\n192.168.4.1\n, \n192.168.4.2\n]\n \\\n  -e KEEPALIVED_VIRTUAL_IPS=192.168.4.3 \\\n  -e KEEPALIVED_PRIORITY=100 \\\n  osixia/keepalived:1.3.5\n\n\n\n\n\nServing\n\n\nThat's it. Each node will talk to the other via unicast (no need to un-firewall multicast addresses), and the node with the highest priority gets to be the master. When ingress traffic arrives on the master node via the VIP, docker's routing mesh will deliver it to the appropriate docker node.\n\n\nChef's notes\n\n\n\n\nSome hosting platforms (OpenStack, for one) won't allow you to simply \"claim\" a virtual IP. Each node is only able to receive traffic targetted to its unique IP. In this case, keepalived is not the right solution, and a platform-specific load-balancing solution should be used. In OpenStack, this is Neutron's \"Load Balancer As A Service\" (LBAAS) component. AWS and Azure would likely include similar protections.\n\n\nMore than 2 nodes can participate in keepalived. Simply ensure that each node has the appropriate priority set, and the node with the highest priority will become the master.", 
            "title": "Keepalived"
        }, 
        {
            "location": "/ha-docker-swarm/keepalived/#keepalived", 
            "text": "While having a self-healing, scalable docker swarm is great for availability and scalability, none of that is any good if nobody can connect to your cluster.  In order to provide seamless external access to clustered resources, regardless of which node they're on and tolerant of node failure, you need to present a single IP to the world for external access.  Normally this is done using a HA loadbalancer, but since Docker Swarm aready provides the load-balancing capabilities (routing mesh), all we need for seamless HA is a virtual IP which will be provided by more than one docker node.  This is accomplished with the use of keepalived on at least two nodes.", 
            "title": "Keepalived"
        }, 
        {
            "location": "/ha-docker-swarm/keepalived/#ingredients", 
            "text": "1\n2\n3\n4\n5\n6 Already deployed:\n[X] At least 2 x CentOS/Fedora Atomic VMs\n[X] low-latency link (i.e., no WAN links)\n\nNew:\n[ ] 3 x IPv4 addresses (one for each node and one for the virtual IP)", 
            "title": "Ingredients"
        }, 
        {
            "location": "/ha-docker-swarm/keepalived/#preparation", 
            "text": "", 
            "title": "Preparation"
        }, 
        {
            "location": "/ha-docker-swarm/keepalived/#enable-ipvs-module", 
            "text": "On all nodes which will participate in keepalived, we need the \"ip_vs\" kernel module, in order to permit serivces to bind to non-local interface addresses.  Set this up once for both the primary and secondary nodes, by running:  1\n2 echo  modprobe ip_vs    /etc/rc.local\nmodprobe ip_vs", 
            "title": "Enable IPVS module"
        }, 
        {
            "location": "/ha-docker-swarm/keepalived/#setup-nodes", 
            "text": "Assuming your IPs are as follows:   192.168.4.1 : Primary  192.168.4.2 : Secondary  192.168.4.3 : Virtual   Run the following on the primary 1\n2\n3\n4\n5\n6 docker run -d --name keepalived --restart=always \\\n  --cap-add=NET_ADMIN --net=host \\\n  -e KEEPALIVED_UNICAST_PEERS= #PYTHON2BASH:[ 192.168.4.1 ,  192.168.4.2 ]  \\\n  -e KEEPALIVED_VIRTUAL_IPS=192.168.4.3 \\\n  -e KEEPALIVED_PRIORITY=200 \\\n  osixia/keepalived:1.3.5   And on the secondary: 1\n2\n3\n4\n5\n6 docker run -d --name keepalived --restart=always \\\n  --cap-add=NET_ADMIN --net=host \\\n  -e KEEPALIVED_UNICAST_PEERS= #PYTHON2BASH:[ 192.168.4.1 ,  192.168.4.2 ]  \\\n  -e KEEPALIVED_VIRTUAL_IPS=192.168.4.3 \\\n  -e KEEPALIVED_PRIORITY=100 \\\n  osixia/keepalived:1.3.5", 
            "title": "Setup nodes"
        }, 
        {
            "location": "/ha-docker-swarm/keepalived/#serving", 
            "text": "That's it. Each node will talk to the other via unicast (no need to un-firewall multicast addresses), and the node with the highest priority gets to be the master. When ingress traffic arrives on the master node via the VIP, docker's routing mesh will deliver it to the appropriate docker node.", 
            "title": "Serving"
        }, 
        {
            "location": "/ha-docker-swarm/keepalived/#chefs-notes", 
            "text": "Some hosting platforms (OpenStack, for one) won't allow you to simply \"claim\" a virtual IP. Each node is only able to receive traffic targetted to its unique IP. In this case, keepalived is not the right solution, and a platform-specific load-balancing solution should be used. In OpenStack, this is Neutron's \"Load Balancer As A Service\" (LBAAS) component. AWS and Azure would likely include similar protections.  More than 2 nodes can participate in keepalived. Simply ensure that each node has the appropriate priority set, and the node with the highest priority will become the master.", 
            "title": "Chef's notes"
        }, 
        {
            "location": "/ha-docker-swarm/docker-swarm-mode/", 
            "text": "Docker Swarm Mode\n\n\nFor truly highly-available services with Docker containers, we need an orchestration system. Docker Swarm (as defined at 1.13) is the simplest way to achieve redundancy, such that a single docker host could be turned off, and none of our services will be interrupted.\n\n\nIngredients\n\n\n\n\n3 x CentOS Atomic hosts (bare-metal or VMs). A reasonable minimum would be:\n\n\n1 x vCPU\n\n\n1GB repo_name\n\n\n10GB HDD\n\n\nHosts must be within the same subnet, and connected on a low-latency link (i.e., no WAN links)\n\n\n\n\nPreparation\n\n\nRelease the swarm!\n\n\nNow, to launch my swarm:\n\n\ndocker swarm init\n\n\nYeah, that was it. Now I have a 1-node swarm.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n[root@ds1 ~]# docker swarm init\nSwarm initialized: current node (b54vls3wf8xztwfz79nlkivt8) is now a manager.\n\nTo add a worker to this swarm, run the following command:\n\n    docker swarm join \\\n    --token SWMTKN-1-2orjbzjzjvm1bbo736xxmxzwaf4rffxwi0tu3zopal4xk4mja0-bsud7xnvhv4cicwi7l6c9s6l0 \\\n    202.170.164.47:2377\n\nTo add a manager to this swarm, run \ndocker swarm join-token manager\n and follow the instructions.\n\n[root@ds1 ~]#\n\n\n\n\n\n\nRun \ndocker node ls\n to confirm that I have a 1-node swarm:\n\n\n1\n2\n3\n4\n[root@ds1 ~]# docker node ls\nID                           HOSTNAME                STATUS  AVAILABILITY  MANAGER STATUS\nb54vls3wf8xztwfz79nlkivt8 *  ds1.funkypenguin.co.nz  Ready   Active        Leader\n[root@ds1 ~]#\n\n\n\n\n\n\nNote that when I ran \ndocker swarm init\n above, the CLI output gave me a command to run to join further nodes to my swarm. This would join the nodes as \nworkers\n (as opposed to \nmanagers\n). Workers can easily be promoted to managers (and demoted again), but since we know that we want our other two nodes to be managers too, it's simpler just to add them to the swarm as managers immediately.\n\n\nOn the first swarm node, generate the necessary token to join another manager by running \ndocker swarm join-token manager\n:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n[root@ds1 ~]# docker swarm join-token manager\nTo add a manager to this swarm, run the following command:\n\n    docker swarm join \\\n    --token SWMTKN-1-2orjbzjzjvm1bbo736xxmxzwaf4rffxwi0tu3zopal4xk4mja0-cfm24bq2zvfkcwujwlp5zqxta \\\n    202.170.164.47:2377\n\n[root@ds1 ~]#\n\n\n\n\n\n\nRun the command provided on your second node to join it to the swarm as a manager. After adding the second node, the output of \ndocker node ls\n (on either host) should reflect two nodes:\n\n\n1\n2\n3\n4\n5\n[root@ds2 davidy]# docker node ls\nID                           HOSTNAME                STATUS  AVAILABILITY  MANAGER STATUS\nb54vls3wf8xztwfz79nlkivt8    ds1.funkypenguin.co.nz  Ready   Active        Leader\nxmw49jt5a1j87a6ihul76gbgy *  ds2.funkypenguin.co.nz  Ready   Active        Reachable\n[root@ds2 davidy]#\n\n\n\n\n\n\nRepeat the process to add your third node. \nYou need a new token for the third node, don't re-use the manager token you generated for the second node\n.\n\n\n\n\nSeriously. Don't use a token more than once, else it's swarm-rebuilding time.\n\n\n\n\nFinally, \ndocker node ls\n should reflect that you have 3 reachable manager nodes, one of whom is the \"Leader\":\n\n\n1\n2\n3\n4\n5\n6\n[root@ds3 ~]# docker node ls\nID                           HOSTNAME                      STATUS  AVAILABILITY  MANAGER STATUS\n36b4twca7i3hkb7qr77i0pr9i    ds1.openstack.dev.safenz.net  Ready   Active        Reachable\nl14rfzazbmibh1p9wcoivkv1s *  ds3.openstack.dev.safenz.net  Ready   Active        Reachable\ntfsgxmu7q23nuo51wwa4ycpsj    ds2.openstack.dev.safenz.net  Ready   Active        Leader\n[root@ds3 ~]#\n\n\n\n\n\n\nCreate registry mirror\n\n\nAlthough we now have shared storage for our persistent container data, our docker nodes don't share any other docker data, such as container images. This results in an inefficiency - every node which participates in the swarm will, at some point, need the docker image for every container deployed in the swarm.\n\n\nWhen dealing with large container (looking at you, GitLab!), this can result in several gigabytes of wasted bandwidth per-node, and long delays when restarting containers on an alternate node. (\nIt also wastes disk space on each node, but we'll get to that in the next section\n)\n\n\nThe solution is to run an official Docker registry container as a \n\"pull-through\" cache, or \"registry mirror\"\n. By using our persistent storage for the registry cache, we can ensure we have a single copy of all the containers we've pulled at least once. After the first pull, any subsequent pulls from our nodes will use the cached version from our registry mirror. As a result, services are available more quickly when restarting container nodes, and we can be more aggressive about cleaning up unused containers on our nodes (more later)\n\n\nThe registry mirror runs as a swarm stack, using a simple docker-compose.yml. Customize \nyour mirror FQDN\n below, so that Traefik will generate the appropriate LetsEncrypt certificates for it, and make it available via HTTPS.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nversion: \n3\n\n\nservices:\n\n  registry-mirror:\n    image: registry:2\n    networks:\n      - traefik\n    deploy:\n      labels:\n        - traefik.frontend.rule=Host:\nyour mirror FQDN\n\n        - traefik.docker.network=traefik\n        - traefik.port=5000\n    ports:\n      - 5000:5000\n    volumes:\n      - /var/data/registry/registry-mirror-data:/var/lib/registry\n      - /var/data/registry/registry-mirror-config.yml:/etc/docker/registry/config.yml\n\nnetworks:\n  traefik:\n    external: true\n\n\n\n\n\n\n\n\nUnencrypted registry\n\n\nWe create this registry without consideration for SSL, which will fail if we attempt to use the registry directly. However, we're going to use the HTTPS-proxied version via Traefik, leveraging Traefik to manage the LetsEncrypt certificates required.\n\n\n\n\nCreate registry/registry-mirror-config.yml as follows:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nversion\n:\n \n0.1\n\n\nlog\n:\n\n  \nfields\n:\n\n    \nservice\n:\n \nregistry\n\n\nstorage\n:\n\n  \ncache\n:\n\n    \nblobdescriptor\n:\n \ninmemory\n\n  \nfilesystem\n:\n\n    \nrootdirectory\n:\n \n/var/lib/\nregistry\n\n  \ndelete\n:\n\n    \nenabled\n:\n \ntrue\n\n\nhttp\n:\n\n  \naddr\n:\n \n:\n5000\n\n  \nheaders\n:\n\n    \nX\n-\nContent\n-\nType\n-\nOptions\n:\n \n[\nnosniff\n]\n\n\nhealth\n:\n\n  \nstoragedriver\n:\n\n    \nenabled\n:\n \ntrue\n\n    \ninterval\n:\n \n10\ns\n\n    \nthreshold\n:\n \n3\n\n\nproxy\n:\n\n  \nremoteurl\n:\n \nhttps\n://\nregistry\n-\n1\n.\ndocker\n.\nio\n\n\n\n\n\n\nEnable registry mirror and experimental features\n\n\nTo tell docker to use the registry mirror, and in order to be able to watch the logs of any service from any manager node (\nan experimental feature in the current Atomic docker build\n), edit \n/etc/docker-latest/daemon.json\n on each node, and change from:\n\n\n1\n2\n3\n4\n{\n    \nlog-driver\n: \njournald\n,\n    \nsignature-verification\n: false\n}\n\n\n\n\n\n\nTo:\n\n\n1\n2\n3\n4\n5\n6\n{\n    \nlog-driver\n: \njournald\n,\n    \nsignature-verification\n: false,\n    \nexperimental\n: true,\n    \nregistry-mirrors\n: [\nhttps://\nyour registry mirror FQDN\n]\n}\n\n\n\n\n\n\n\n\nNote the extra comma required after \"false\" above\n\n\n\n\nSetup automated cleanup\n\n\nThis needs to be a docker-compose.yml file, excluding trusted images (like glusterfs, traefik, etc)\n\n1\n2\n3\n4\ndocker run -d  \\\n-v /var/run/docker.sock:/var/run/docker.sock:rw \\\n-v /var/lib/docker:/var/lib/docker:rw  \\\nmeltwater/docker-cleanup:latest\n\n\n\n\n\nTweaks\n\n\nAdd some handy bash auto-completion for docker. Without this, you'll get annoyed that you can't autocomplete \ndocker stack deploy \nblah\n -c \nblah.yml\n commands.\n\n\n1\n2\ncd /etc/bash_completion.d/\ncurl -O https://raw.githubusercontent.com/docker/cli/b75596e1e4d5295ac69b9934d1bd8aff691a0de8/contrib/completion/bash/docker\n\n\n\n\n\n\nInstall some useful bash aliases on each host\n\n1\n2\n3\ncd ~\ncurl -O https://gitlab.funkypenguin.co.nz/funkypenguin/geeks-cookbook-recipies/raw/master/bash/gcb-aliases.sh\necho \nsource ~/gcb-aliases.sh\n \n ~/.bash_profile\n\n\n\n\n\n1\n2\n3\n4\n5\nmkdir ~/dockersock\ncd ~/dockersock\ncurl -O https://raw.githubusercontent.com/dpw/selinux-dockersock/master/Makefile\ncurl -O https://raw.githubusercontent.com/dpw/selinux-dockersock/master/dockersock.te\nmake \n semodule -i dockersock.pp\n\n\n\n\n\n\nSetup registry\n\n\ndocker run -d \\\n  -p 5000:5000 \\\n  --restart=always \\\n  --name registry \\\n  -v /mnt/registry:/var/lib/registry \\\n  registry:2\n\n\n{\n\"log-driver\": \"journald\",\n\"signature-verification\": false,\n\"experimental\": true,\n\"registry-mirrors\": [\"\nhttps://registry-mirror.funkypenguin.co.nz\n\"]\n}\n\n\nregistry-mirror:\n    image: registry:2\n    ports:\n      - 5000:5000\n    environment:\n    volumes:\n      - /var/data/registry:/var/lib/registry\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n  [root@ds1 dockersock]# docker swarm join-token manager\n  To add a manager to this swarm, run the following command:\n\n      docker swarm join \\\n      --token SWMTKN-1-09c94wv0opw0y6xg67uzjl13pnv8lxxn586hrg5f47spso9l6j-6zn3dxk7c4zkb19r61owasi15 \\\n      192.168.31.11:2377\n\n  [root@ds1 dockersock]#", 
            "title": "Docker Swarm Mode"
        }, 
        {
            "location": "/ha-docker-swarm/docker-swarm-mode/#docker-swarm-mode", 
            "text": "For truly highly-available services with Docker containers, we need an orchestration system. Docker Swarm (as defined at 1.13) is the simplest way to achieve redundancy, such that a single docker host could be turned off, and none of our services will be interrupted.", 
            "title": "Docker Swarm Mode"
        }, 
        {
            "location": "/ha-docker-swarm/docker-swarm-mode/#ingredients", 
            "text": "3 x CentOS Atomic hosts (bare-metal or VMs). A reasonable minimum would be:  1 x vCPU  1GB repo_name  10GB HDD  Hosts must be within the same subnet, and connected on a low-latency link (i.e., no WAN links)", 
            "title": "Ingredients"
        }, 
        {
            "location": "/ha-docker-swarm/docker-swarm-mode/#preparation", 
            "text": "", 
            "title": "Preparation"
        }, 
        {
            "location": "/ha-docker-swarm/docker-swarm-mode/#release-the-swarm", 
            "text": "Now, to launch my swarm:  docker swarm init  Yeah, that was it. Now I have a 1-node swarm.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 [root@ds1 ~]# docker swarm init\nSwarm initialized: current node (b54vls3wf8xztwfz79nlkivt8) is now a manager.\n\nTo add a worker to this swarm, run the following command:\n\n    docker swarm join \\\n    --token SWMTKN-1-2orjbzjzjvm1bbo736xxmxzwaf4rffxwi0tu3zopal4xk4mja0-bsud7xnvhv4cicwi7l6c9s6l0 \\\n    202.170.164.47:2377\n\nTo add a manager to this swarm, run  docker swarm join-token manager  and follow the instructions.\n\n[root@ds1 ~]#   Run  docker node ls  to confirm that I have a 1-node swarm:  1\n2\n3\n4 [root@ds1 ~]# docker node ls\nID                           HOSTNAME                STATUS  AVAILABILITY  MANAGER STATUS\nb54vls3wf8xztwfz79nlkivt8 *  ds1.funkypenguin.co.nz  Ready   Active        Leader\n[root@ds1 ~]#   Note that when I ran  docker swarm init  above, the CLI output gave me a command to run to join further nodes to my swarm. This would join the nodes as  workers  (as opposed to  managers ). Workers can easily be promoted to managers (and demoted again), but since we know that we want our other two nodes to be managers too, it's simpler just to add them to the swarm as managers immediately.  On the first swarm node, generate the necessary token to join another manager by running  docker swarm join-token manager :  1\n2\n3\n4\n5\n6\n7\n8 [root@ds1 ~]# docker swarm join-token manager\nTo add a manager to this swarm, run the following command:\n\n    docker swarm join \\\n    --token SWMTKN-1-2orjbzjzjvm1bbo736xxmxzwaf4rffxwi0tu3zopal4xk4mja0-cfm24bq2zvfkcwujwlp5zqxta \\\n    202.170.164.47:2377\n\n[root@ds1 ~]#   Run the command provided on your second node to join it to the swarm as a manager. After adding the second node, the output of  docker node ls  (on either host) should reflect two nodes:  1\n2\n3\n4\n5 [root@ds2 davidy]# docker node ls\nID                           HOSTNAME                STATUS  AVAILABILITY  MANAGER STATUS\nb54vls3wf8xztwfz79nlkivt8    ds1.funkypenguin.co.nz  Ready   Active        Leader\nxmw49jt5a1j87a6ihul76gbgy *  ds2.funkypenguin.co.nz  Ready   Active        Reachable\n[root@ds2 davidy]#   Repeat the process to add your third node.  You need a new token for the third node, don't re-use the manager token you generated for the second node .   Seriously. Don't use a token more than once, else it's swarm-rebuilding time.   Finally,  docker node ls  should reflect that you have 3 reachable manager nodes, one of whom is the \"Leader\":  1\n2\n3\n4\n5\n6 [root@ds3 ~]# docker node ls\nID                           HOSTNAME                      STATUS  AVAILABILITY  MANAGER STATUS\n36b4twca7i3hkb7qr77i0pr9i    ds1.openstack.dev.safenz.net  Ready   Active        Reachable\nl14rfzazbmibh1p9wcoivkv1s *  ds3.openstack.dev.safenz.net  Ready   Active        Reachable\ntfsgxmu7q23nuo51wwa4ycpsj    ds2.openstack.dev.safenz.net  Ready   Active        Leader\n[root@ds3 ~]#", 
            "title": "Release the swarm!"
        }, 
        {
            "location": "/ha-docker-swarm/docker-swarm-mode/#create-registry-mirror", 
            "text": "Although we now have shared storage for our persistent container data, our docker nodes don't share any other docker data, such as container images. This results in an inefficiency - every node which participates in the swarm will, at some point, need the docker image for every container deployed in the swarm.  When dealing with large container (looking at you, GitLab!), this can result in several gigabytes of wasted bandwidth per-node, and long delays when restarting containers on an alternate node. ( It also wastes disk space on each node, but we'll get to that in the next section )  The solution is to run an official Docker registry container as a  \"pull-through\" cache, or \"registry mirror\" . By using our persistent storage for the registry cache, we can ensure we have a single copy of all the containers we've pulled at least once. After the first pull, any subsequent pulls from our nodes will use the cached version from our registry mirror. As a result, services are available more quickly when restarting container nodes, and we can be more aggressive about cleaning up unused containers on our nodes (more later)  The registry mirror runs as a swarm stack, using a simple docker-compose.yml. Customize  your mirror FQDN  below, so that Traefik will generate the appropriate LetsEncrypt certificates for it, and make it available via HTTPS.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 version:  3 \n\nservices:\n\n  registry-mirror:\n    image: registry:2\n    networks:\n      - traefik\n    deploy:\n      labels:\n        - traefik.frontend.rule=Host: your mirror FQDN \n        - traefik.docker.network=traefik\n        - traefik.port=5000\n    ports:\n      - 5000:5000\n    volumes:\n      - /var/data/registry/registry-mirror-data:/var/lib/registry\n      - /var/data/registry/registry-mirror-config.yml:/etc/docker/registry/config.yml\n\nnetworks:\n  traefik:\n    external: true    Unencrypted registry  We create this registry without consideration for SSL, which will fail if we attempt to use the registry directly. However, we're going to use the HTTPS-proxied version via Traefik, leveraging Traefik to manage the LetsEncrypt certificates required.   Create registry/registry-mirror-config.yml as follows:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 version :   0.1  log : \n   fields : \n     service :   registry  storage : \n   cache : \n     blobdescriptor :   inmemory \n   filesystem : \n     rootdirectory :   /var/lib/ registry \n   delete : \n     enabled :   true  http : \n   addr :   : 5000 \n   headers : \n     X - Content - Type - Options :   [ nosniff ]  health : \n   storagedriver : \n     enabled :   true \n     interval :   10 s \n     threshold :   3  proxy : \n   remoteurl :   https :// registry - 1 . docker . io", 
            "title": "Create registry mirror"
        }, 
        {
            "location": "/ha-docker-swarm/docker-swarm-mode/#enable-registry-mirror-and-experimental-features", 
            "text": "To tell docker to use the registry mirror, and in order to be able to watch the logs of any service from any manager node ( an experimental feature in the current Atomic docker build ), edit  /etc/docker-latest/daemon.json  on each node, and change from:  1\n2\n3\n4 {\n     log-driver :  journald ,\n     signature-verification : false\n}   To:  1\n2\n3\n4\n5\n6 {\n     log-driver :  journald ,\n     signature-verification : false,\n     experimental : true,\n     registry-mirrors : [ https:// your registry mirror FQDN ]\n}    Note the extra comma required after \"false\" above", 
            "title": "Enable registry mirror and experimental features"
        }, 
        {
            "location": "/ha-docker-swarm/docker-swarm-mode/#setup-automated-cleanup", 
            "text": "This needs to be a docker-compose.yml file, excluding trusted images (like glusterfs, traefik, etc) 1\n2\n3\n4 docker run -d  \\\n-v /var/run/docker.sock:/var/run/docker.sock:rw \\\n-v /var/lib/docker:/var/lib/docker:rw  \\\nmeltwater/docker-cleanup:latest", 
            "title": "Setup automated cleanup"
        }, 
        {
            "location": "/ha-docker-swarm/docker-swarm-mode/#tweaks", 
            "text": "Add some handy bash auto-completion for docker. Without this, you'll get annoyed that you can't autocomplete  docker stack deploy  blah  -c  blah.yml  commands.  1\n2 cd /etc/bash_completion.d/\ncurl -O https://raw.githubusercontent.com/docker/cli/b75596e1e4d5295ac69b9934d1bd8aff691a0de8/contrib/completion/bash/docker   Install some useful bash aliases on each host 1\n2\n3 cd ~\ncurl -O https://gitlab.funkypenguin.co.nz/funkypenguin/geeks-cookbook-recipies/raw/master/bash/gcb-aliases.sh\necho  source ~/gcb-aliases.sh    ~/.bash_profile   1\n2\n3\n4\n5 mkdir ~/dockersock\ncd ~/dockersock\ncurl -O https://raw.githubusercontent.com/dpw/selinux-dockersock/master/Makefile\ncurl -O https://raw.githubusercontent.com/dpw/selinux-dockersock/master/dockersock.te\nmake   semodule -i dockersock.pp", 
            "title": "Tweaks"
        }, 
        {
            "location": "/ha-docker-swarm/docker-swarm-mode/#setup-registry", 
            "text": "docker run -d \\\n  -p 5000:5000 \\\n  --restart=always \\\n  --name registry \\\n  -v /mnt/registry:/var/lib/registry \\\n  registry:2  {\n\"log-driver\": \"journald\",\n\"signature-verification\": false,\n\"experimental\": true,\n\"registry-mirrors\": [\" https://registry-mirror.funkypenguin.co.nz \"]\n}  registry-mirror:\n    image: registry:2\n    ports:\n      - 5000:5000\n    environment:\n    volumes:\n      - /var/data/registry:/var/lib/registry  1\n2\n3\n4\n5\n6\n7\n8   [root@ds1 dockersock]# docker swarm join-token manager\n  To add a manager to this swarm, run the following command:\n\n      docker swarm join \\\n      --token SWMTKN-1-09c94wv0opw0y6xg67uzjl13pnv8lxxn586hrg5f47spso9l6j-6zn3dxk7c4zkb19r61owasi15 \\\n      192.168.31.11:2377\n\n  [root@ds1 dockersock]#", 
            "title": "Setup registry"
        }, 
        {
            "location": "/ha-docker-swarm/traefik/", 
            "text": "Traefik\n\n\nThe platforms we plan to run on our cloud are generally web-based, and each listening on their own unique TCP port. When a container in a swarm exposes a port, then connecting to \nany\n swarm member on that port will result in your request being forwarded to the appropriate host running the container. (\nDocker calls this the swarm \"\nrouting mesh\n\"\n)\n\n\nSo we get a rudimentary load balancer built into swarm. We could stop there, just exposing a series of ports on our hosts, and making them HA using keepalived.\n\n\nThere are some gaps to this approach though:\n\n\n\n\nNo consideration is given to HTTPS. Implementation would have to be done manually, per-container.\n\n\nNo mechanism is provided for authentication outside of that which the container providers. We may not \nwant\n to expose every interface on every container to the world, especially if we are playing with tools or containers whose quality and origin are unknown.\n\n\n\n\nTo deal with these gaps, we need a front-end load-balancer, and in this design, that role is provided by \nTraefik\n.\n\n\nIngredients\n\n\nPreparation\n\n\nPrepare the host\n\n\nThe traefik container is aware of the \nother\n docker containers in the swarm, because it has access to the docker socket at \n/var/run/docker.sock\n. This allows traefik to dynamically configure itself based on the labels found on containers in the swarm, which is hugely useful. To make this functionality work on our SELinux-enabled Atomic hosts, we need to add custom SELinux policy.\n\n\nRun the following to build and activate policy to permit containers to access docker.sock:\n\n\n1\n2\n3\n4\n5\n6\n7\nmkdir ~/dockersock\ncd ~/dockersock\ncurl -O https://raw.githubusercontent.com/dpw/\\\nselinux-dockersock/master/Makefile\ncurl -O https://raw.githubusercontent.com/dpw/\\\nselinux-dockersock/master/dockersock.te\nmake \n semodule -i dockersock.pp\n\n\n\n\n\n\nPrepare traefik.toml\n\n\nWhile it's possible to configure traefik via docker command arguments, I prefer to create a config file (traefik.toml). This allows me to change traefik's behaviour by simply changing the file, and keeps my docker config simple.\n\n\nCreate /var/data/traefik/traefik.toml as follows:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\ncheckNewVersion = true\ndefaultEntryPoints = [\nhttp\n, \nhttps\n]\n\n# This section enable LetsEncrypt automatic certificate generation / renewal\n[acme]\nemail = \nyour LetsEncrypt email address\n\nstorage = \nacme.json\n # or \ntraefik/acme/account\n if using KV store\nentryPoint = \nhttps\n\nacmeLogging = true\nonDemand = true\nOnHostRule = true\n\n[[acme.domains]]\n  main = \nyour primary domain\n\n\n# Redirect all HTTP to HTTPS (why wouldn\nt you?)\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n    [entryPoints.http.redirect]\n      entryPoint = \nhttps\n\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n\n[web]\naddress = \n:8080\n\nwatch = true\n\n[docker]\nendpoint = \ntcp://127.0.0.1:2375\n\ndomain = \nyour primary domain\n\nwatch = true\nswarmmode = true\n\n\n\n\n\n\nPrepare the docker service config\n\n\nCreate /var/data/traefik/docker-compose.yml as follows:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\nversion: \n3.2\n\n\nservices:\n  traefik:\n    image: traefik\n    command: --web --docker --docker.swarmmode --docker.watch --docker.domain=funkypenguin.co.nz --logLevel=DEBUG\n    ports:\n      - target: 80\n        published: 80\n        protocol: tcp\n        mode: host\n      - target: 443\n        published: 443\n        protocol: tcp\n        mode: host\n      - target: 8080\n        published: 8080\n        protocol: tcp\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      - /var/data/traefik/traefik.toml:/traefik.toml:ro\n      - /var/data/traefik/acme.json:/acme.json\n    labels:\n      - \ntraefik.enable=false\n\n    networks:\n      - public\n    deploy:\n      mode: global\n      placement:\n        constraints: [node.role == manager]\n      restart_policy:\n        condition: on-failure\n\nnetworks:\n  public:\n    driver: overlay\n    ipam:\n      driver: default\n      config:\n      - subnet: 10.1.0.0/24\n\n\n\n\n\n\nDocker won't start an image with a bind-mount to a non-existent file, so prepare acme.json by running \ntouch /var/data/traefik/acme.json\n.\n\n\nLaunch\n\n\nDeploy traefik with \ndocker stack deploy traefik -c /var/data/traefik/docker-compose.yml\n\n\nConfirm traefik is running with \ndocker stack ps traefik\n\n\nServing\n\n\nYou now have:\n\n\n\n\nFrontend proxy which will dynamically configure itself for new backend containers\n\n\nAutomatic SSL support for all proxied resources\n\n\n\n\nChef's Notes\n\n\nAdditional features I'd like to see in this recipe are:\n\n\n\n\nInclude documentation of oauth2_proxy container for protecting individual backends\n\n\nTraefik webUI is available via HTTPS, protected with oauth_proxy\n\n\nPending a feature in docker-swarm to avoid NAT on routing-mesh-delivered traffic, update the design", 
            "title": "Traefik"
        }, 
        {
            "location": "/ha-docker-swarm/traefik/#traefik", 
            "text": "The platforms we plan to run on our cloud are generally web-based, and each listening on their own unique TCP port. When a container in a swarm exposes a port, then connecting to  any  swarm member on that port will result in your request being forwarded to the appropriate host running the container. ( Docker calls this the swarm \" routing mesh \" )  So we get a rudimentary load balancer built into swarm. We could stop there, just exposing a series of ports on our hosts, and making them HA using keepalived.  There are some gaps to this approach though:   No consideration is given to HTTPS. Implementation would have to be done manually, per-container.  No mechanism is provided for authentication outside of that which the container providers. We may not  want  to expose every interface on every container to the world, especially if we are playing with tools or containers whose quality and origin are unknown.   To deal with these gaps, we need a front-end load-balancer, and in this design, that role is provided by  Traefik .", 
            "title": "Traefik"
        }, 
        {
            "location": "/ha-docker-swarm/traefik/#ingredients", 
            "text": "", 
            "title": "Ingredients"
        }, 
        {
            "location": "/ha-docker-swarm/traefik/#preparation", 
            "text": "", 
            "title": "Preparation"
        }, 
        {
            "location": "/ha-docker-swarm/traefik/#prepare-the-host", 
            "text": "The traefik container is aware of the  other  docker containers in the swarm, because it has access to the docker socket at  /var/run/docker.sock . This allows traefik to dynamically configure itself based on the labels found on containers in the swarm, which is hugely useful. To make this functionality work on our SELinux-enabled Atomic hosts, we need to add custom SELinux policy.  Run the following to build and activate policy to permit containers to access docker.sock:  1\n2\n3\n4\n5\n6\n7 mkdir ~/dockersock\ncd ~/dockersock\ncurl -O https://raw.githubusercontent.com/dpw/\\\nselinux-dockersock/master/Makefile\ncurl -O https://raw.githubusercontent.com/dpw/\\\nselinux-dockersock/master/dockersock.te\nmake   semodule -i dockersock.pp", 
            "title": "Prepare the host"
        }, 
        {
            "location": "/ha-docker-swarm/traefik/#prepare-traefiktoml", 
            "text": "While it's possible to configure traefik via docker command arguments, I prefer to create a config file (traefik.toml). This allows me to change traefik's behaviour by simply changing the file, and keeps my docker config simple.  Create /var/data/traefik/traefik.toml as follows:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34 checkNewVersion = true\ndefaultEntryPoints = [ http ,  https ]\n\n# This section enable LetsEncrypt automatic certificate generation / renewal\n[acme]\nemail =  your LetsEncrypt email address \nstorage =  acme.json  # or  traefik/acme/account  if using KV store\nentryPoint =  https \nacmeLogging = true\nonDemand = true\nOnHostRule = true\n\n[[acme.domains]]\n  main =  your primary domain \n\n# Redirect all HTTP to HTTPS (why wouldn t you?)\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n    [entryPoints.http.redirect]\n      entryPoint =  https \n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n\n[web]\naddress =  :8080 \nwatch = true\n\n[docker]\nendpoint =  tcp://127.0.0.1:2375 \ndomain =  your primary domain \nwatch = true\nswarmmode = true", 
            "title": "Prepare traefik.toml"
        }, 
        {
            "location": "/ha-docker-swarm/traefik/#prepare-the-docker-service-config", 
            "text": "Create /var/data/traefik/docker-compose.yml as follows:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40 version:  3.2 \n\nservices:\n  traefik:\n    image: traefik\n    command: --web --docker --docker.swarmmode --docker.watch --docker.domain=funkypenguin.co.nz --logLevel=DEBUG\n    ports:\n      - target: 80\n        published: 80\n        protocol: tcp\n        mode: host\n      - target: 443\n        published: 443\n        protocol: tcp\n        mode: host\n      - target: 8080\n        published: 8080\n        protocol: tcp\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      - /var/data/traefik/traefik.toml:/traefik.toml:ro\n      - /var/data/traefik/acme.json:/acme.json\n    labels:\n      -  traefik.enable=false \n    networks:\n      - public\n    deploy:\n      mode: global\n      placement:\n        constraints: [node.role == manager]\n      restart_policy:\n        condition: on-failure\n\nnetworks:\n  public:\n    driver: overlay\n    ipam:\n      driver: default\n      config:\n      - subnet: 10.1.0.0/24   Docker won't start an image with a bind-mount to a non-existent file, so prepare acme.json by running  touch /var/data/traefik/acme.json .", 
            "title": "Prepare the docker service config"
        }, 
        {
            "location": "/ha-docker-swarm/traefik/#launch", 
            "text": "Deploy traefik with  docker stack deploy traefik -c /var/data/traefik/docker-compose.yml  Confirm traefik is running with  docker stack ps traefik", 
            "title": "Launch"
        }, 
        {
            "location": "/ha-docker-swarm/traefik/#serving", 
            "text": "You now have:   Frontend proxy which will dynamically configure itself for new backend containers  Automatic SSL support for all proxied resources", 
            "title": "Serving"
        }, 
        {
            "location": "/ha-docker-swarm/traefik/#chefs-notes", 
            "text": "Additional features I'd like to see in this recipe are:   Include documentation of oauth2_proxy container for protecting individual backends  Traefik webUI is available via HTTPS, protected with oauth_proxy  Pending a feature in docker-swarm to avoid NAT on routing-mesh-delivered traffic, update the design", 
            "title": "Chef's Notes"
        }, 
        {
            "location": "/recipies/mail/", 
            "text": "Mail Server\n\n\nMany of the recipies that follow require email access of some kind. It's quite accepmatebl normally possible to use a hosted service such as SendGrid, or just a gmail account. If (like me) you'd like to self-host email for your stacks, then the following recipe provides a full-stack mail server running on the docker HA swarm.\n\n\nOf value to me in choosing docker-mailserver were:\n\n\n\n\nAutomatically renews LetsEncrypt certificates\n\n\nCreation of email accounts across multiple domains (i.e., the same container gives me mailbox \n, and \n)\n\n\nThe entire configuration is based on flat files, so there's no database or persistence to worry about\n\n\n\n\ndocker-mailserver doesn't include a webmail client, and one is not strictly needed. Rainloop can be added either as another service within the stack, or as a standalone service. Rainloop will be covered in a future recipe.\n\n\nIngredients\n\n\n\n\nDocker swarm cluster\n with \npersistent shared storage\n\n\nTraefik\n configured per design\n\n\nLetsEncrypt authorized email address for domain\n\n\nAccess to manage DNS records for domains\n\n\n\n\nPreparation\n\n\nSetup data locations\n\n\nWe'll need several directories to bind-mount into our container, so create them in /var/data/mailserver:\n\n\n1\n2\n3\n4\ncd /var/data\nmkdir mailserver\ncd mailserver\nmkdir {maildata,mailstate,config,letsencrypt}\n\n\n\n\n\n\nGet LetsEncrypt certificate\n\n\nDecide on the FQDN to assign to your mailserver. You can service multiple domains from a single mailserver - i.e., \n and \n can both be served by \nmail.example.com\n.\n\n\nThe docker-mailserver container can \nrenew\n our LetsEncrypt certs for us, but it can't generate them. To do this, we need to run certbot (from a container) to request the initial certs and create the appropriate directory structure.\n\n\nIn the example below, since I'm already using Traefik to manage the LE certs for my web platforms, I opted to use the DNS challenge to prove my ownership of the domain. The certbot client will prompt you to add a DNS record for domain verification.\n\n\n1\n2\n3\n4\ndocker run -ti --rm -v \\\n\n$(pwd)\n/letsencrypt:/etc/letsencrypt certbot/certbot \\\n--manual --preferred-challenges dns certonly \\\n-d mail.example.com\n\n\n\n\n\n\nGet setup.sh\n\n\ndocker-mailserver comes with a handy bash script for managing the stack (which is just really a wrapper around the container.) It'll make our setup easier, so download it into the root of your configuration/data directory, and make it executable:\n\n\n1\n2\n3\ncurl -o setup.sh \\\nhttps://raw.githubusercontent.com/tomav/docker-mailserver/master/setup.sh \\\nchmod a+x ./setup.sh\n\n\n\n\n\n\nCreate email accounts\n\n\nFor every email address required, run \n./setup.sh email add \nemail\n \npassword\n to create the account. The command returns no output.\n\n\nYou can run \n./setup.sh email list\n to confirm all of your addresses have been created.\n\n\nCreate DKIM DNS entries\n\n\nRun \n./setup.sh config dkim\n to create the necessary DKIM entries. The command returns no output.\n\n\nExamine the keys created by opendkim to identify the DNS TXT records required:\n\n\n1\n2\n3\n4\nfor i in `find config/opendkim/keys/ -name mail.txt`; do \\\necho $i; \\\ncat $i; \\\ndone\n\n\n\n\n\n\nYou'll end up with something like this:\n\n\n1\n2\n3\n4\nconfig/opendkim/keys/gitlab.example.com/mail.txt\nmail._domainkey IN  TXT ( \nv=DKIM1; k=rsa; \n\n      \np=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCYuQqDg2ZG8ZOfI1PvarF1Gcr5cJnCR8BeCj5HYgeRohSrxKL5utPEF/AWAxXYwnKpgYN837fu74GfqsIuOhu70lPhGV+O2gFVgpXYWHELvIiTqqO0QgarIN63WE2gzE4s0FckfLrMuxMoXr882wuzuJhXywGxOavybmjpnNHhbQIDAQAB\n )  ; ----- DKIM key mail for gitlab.example.com\n[root@ds1 mail]#\n\n\n\n\n\n\nCreate the necessary DNS TXT entries for your domain(s). Note that although opendkim splits the record across two lines, the actual record should be concatenated on creation. I.e., the DNS TXT record above should read:\n\n\n1\nv=DKIM1; k=rsa; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCYuQqDg2ZG8ZOfI1PvarF1Gcr5cJnCR8BeCj5HYgeRohSrxKL5utPEF/AWAxXYwnKpgYN837fu74GfqsIuOhu70lPhGV+O2gFVgpXYWHELvIiTqqO0QgarIN63WE2gzE4s0FckfLrMuxMoXr882wuzuJhXywGxOavybmjpnNHhbQIDAQAB\n\n\n\n\n\n\n\nSetup Docker Swarm\n\n\nCreate a docker swarm config file in docker-compose syntax (v3), something like this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nversion: \n3\n\n\nservices:\n  mail:\n    image: tvial/docker-mailserver:latest\n    ports:\n      - \n25:25\n\n      - \n587:587\n\n      - \n993:993\n\n    volumes:\n      - /var/data/mail/maildata:/var/mail\n      - /var/data/mail/mailstate:/var/mail-state\n      - /var/data/mail/config:/tmp/docker-mailserver\n      - /var/data/mail/letsencrypt:/etc/letsencrypt\n    env_file: /var/data/mail/.env\n    networks:\n      - internal\n    deploy:\n      replicas: 1\n\nnetworks:\n  traefik:\n    external: true\n  internal:\n    driver: overlay\n    ipam:\n      config:\n        - subnet: 172.16.2.0/24\n\n\n\n\n\n\n\n\nTip\n\n\nSetup unique static subnets for every stack you deploy. This avoids IP/gateway conflicts which can otherwise occur when you're creating/removing stacks a lot.\n\n\n\n\nA sample .env file looks like this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nENABLE_SPAMASSASSIN=1\nENABLE_CLAMAV=1\nENABLE_POSTGREY=1\nONE_DIR=1\nOVERRIDE_HOSTNAME=mail.example.com\nOVERRIDE_DOMAINNAME=mail.example.com\nPOSTMASTER_ADDRESS=admin@example.com\nPERMIT_DOCKER=network\nSSL_TYPE=letsencrypt\n\n\n\n\n\n\nServing\n\n\nLaunch mailserver\n\n\nLaunch the mail server stack by running \ndocker stack deploy mailserver -c \npath -to-docker-compose.yml\n\n\nChef's Notes\n\n\n\n\nOne of the elements of this design which I didn't appreciate at first is that since the config is entirely file-based, \nsetup.sh\n can be run on any container host, provided it has the shared data mounted. This means that even though docker-mailserver was not designed with docker swarm in mind, it works perfectl with swarm. I.e., from any node, regardless of where the container is actually running, you're able to add/delete email addresses, view logs, etc.", 
            "title": "Mail Server"
        }, 
        {
            "location": "/recipies/mail/#mail-server", 
            "text": "Many of the recipies that follow require email access of some kind. It's quite accepmatebl normally possible to use a hosted service such as SendGrid, or just a gmail account. If (like me) you'd like to self-host email for your stacks, then the following recipe provides a full-stack mail server running on the docker HA swarm.  Of value to me in choosing docker-mailserver were:   Automatically renews LetsEncrypt certificates  Creation of email accounts across multiple domains (i.e., the same container gives me mailbox  , and  )  The entire configuration is based on flat files, so there's no database or persistence to worry about   docker-mailserver doesn't include a webmail client, and one is not strictly needed. Rainloop can be added either as another service within the stack, or as a standalone service. Rainloop will be covered in a future recipe.", 
            "title": "Mail Server"
        }, 
        {
            "location": "/recipies/mail/#ingredients", 
            "text": "Docker swarm cluster  with  persistent shared storage  Traefik  configured per design  LetsEncrypt authorized email address for domain  Access to manage DNS records for domains", 
            "title": "Ingredients"
        }, 
        {
            "location": "/recipies/mail/#preparation", 
            "text": "", 
            "title": "Preparation"
        }, 
        {
            "location": "/recipies/mail/#setup-data-locations", 
            "text": "We'll need several directories to bind-mount into our container, so create them in /var/data/mailserver:  1\n2\n3\n4 cd /var/data\nmkdir mailserver\ncd mailserver\nmkdir {maildata,mailstate,config,letsencrypt}", 
            "title": "Setup data locations"
        }, 
        {
            "location": "/recipies/mail/#get-letsencrypt-certificate", 
            "text": "Decide on the FQDN to assign to your mailserver. You can service multiple domains from a single mailserver - i.e.,   and   can both be served by  mail.example.com .  The docker-mailserver container can  renew  our LetsEncrypt certs for us, but it can't generate them. To do this, we need to run certbot (from a container) to request the initial certs and create the appropriate directory structure.  In the example below, since I'm already using Traefik to manage the LE certs for my web platforms, I opted to use the DNS challenge to prove my ownership of the domain. The certbot client will prompt you to add a DNS record for domain verification.  1\n2\n3\n4 docker run -ti --rm -v \\ $(pwd) /letsencrypt:/etc/letsencrypt certbot/certbot \\\n--manual --preferred-challenges dns certonly \\\n-d mail.example.com", 
            "title": "Get LetsEncrypt certificate"
        }, 
        {
            "location": "/recipies/mail/#get-setupsh", 
            "text": "docker-mailserver comes with a handy bash script for managing the stack (which is just really a wrapper around the container.) It'll make our setup easier, so download it into the root of your configuration/data directory, and make it executable:  1\n2\n3 curl -o setup.sh \\\nhttps://raw.githubusercontent.com/tomav/docker-mailserver/master/setup.sh \\\nchmod a+x ./setup.sh", 
            "title": "Get setup.sh"
        }, 
        {
            "location": "/recipies/mail/#create-email-accounts", 
            "text": "For every email address required, run  ./setup.sh email add  email   password  to create the account. The command returns no output.  You can run  ./setup.sh email list  to confirm all of your addresses have been created.", 
            "title": "Create email accounts"
        }, 
        {
            "location": "/recipies/mail/#create-dkim-dns-entries", 
            "text": "Run  ./setup.sh config dkim  to create the necessary DKIM entries. The command returns no output.  Examine the keys created by opendkim to identify the DNS TXT records required:  1\n2\n3\n4 for i in `find config/opendkim/keys/ -name mail.txt`; do \\\necho $i; \\\ncat $i; \\\ndone   You'll end up with something like this:  1\n2\n3\n4 config/opendkim/keys/gitlab.example.com/mail.txt\nmail._domainkey IN  TXT (  v=DKIM1; k=rsa;  \n       p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCYuQqDg2ZG8ZOfI1PvarF1Gcr5cJnCR8BeCj5HYgeRohSrxKL5utPEF/AWAxXYwnKpgYN837fu74GfqsIuOhu70lPhGV+O2gFVgpXYWHELvIiTqqO0QgarIN63WE2gzE4s0FckfLrMuxMoXr882wuzuJhXywGxOavybmjpnNHhbQIDAQAB  )  ; ----- DKIM key mail for gitlab.example.com\n[root@ds1 mail]#   Create the necessary DNS TXT entries for your domain(s). Note that although opendkim splits the record across two lines, the actual record should be concatenated on creation. I.e., the DNS TXT record above should read:  1 v=DKIM1; k=rsa; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCYuQqDg2ZG8ZOfI1PvarF1Gcr5cJnCR8BeCj5HYgeRohSrxKL5utPEF/AWAxXYwnKpgYN837fu74GfqsIuOhu70lPhGV+O2gFVgpXYWHELvIiTqqO0QgarIN63WE2gzE4s0FckfLrMuxMoXr882wuzuJhXywGxOavybmjpnNHhbQIDAQAB", 
            "title": "Create DKIM DNS entries"
        }, 
        {
            "location": "/recipies/mail/#setup-docker-swarm", 
            "text": "Create a docker swarm config file in docker-compose syntax (v3), something like this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 version:  3 \n\nservices:\n  mail:\n    image: tvial/docker-mailserver:latest\n    ports:\n      -  25:25 \n      -  587:587 \n      -  993:993 \n    volumes:\n      - /var/data/mail/maildata:/var/mail\n      - /var/data/mail/mailstate:/var/mail-state\n      - /var/data/mail/config:/tmp/docker-mailserver\n      - /var/data/mail/letsencrypt:/etc/letsencrypt\n    env_file: /var/data/mail/.env\n    networks:\n      - internal\n    deploy:\n      replicas: 1\n\nnetworks:\n  traefik:\n    external: true\n  internal:\n    driver: overlay\n    ipam:\n      config:\n        - subnet: 172.16.2.0/24    Tip  Setup unique static subnets for every stack you deploy. This avoids IP/gateway conflicts which can otherwise occur when you're creating/removing stacks a lot.   A sample .env file looks like this:  1\n2\n3\n4\n5\n6\n7\n8\n9 ENABLE_SPAMASSASSIN=1\nENABLE_CLAMAV=1\nENABLE_POSTGREY=1\nONE_DIR=1\nOVERRIDE_HOSTNAME=mail.example.com\nOVERRIDE_DOMAINNAME=mail.example.com\nPOSTMASTER_ADDRESS=admin@example.com\nPERMIT_DOCKER=network\nSSL_TYPE=letsencrypt", 
            "title": "Setup Docker Swarm"
        }, 
        {
            "location": "/recipies/mail/#serving", 
            "text": "", 
            "title": "Serving"
        }, 
        {
            "location": "/recipies/mail/#launch-mailserver", 
            "text": "Launch the mail server stack by running  docker stack deploy mailserver -c  path -to-docker-compose.yml", 
            "title": "Launch mailserver"
        }, 
        {
            "location": "/recipies/mail/#chefs-notes", 
            "text": "One of the elements of this design which I didn't appreciate at first is that since the config is entirely file-based,  setup.sh  can be run on any container host, provided it has the shared data mounted. This means that even though docker-mailserver was not designed with docker swarm in mind, it works perfectl with swarm. I.e., from any node, regardless of where the container is actually running, you're able to add/delete email addresses, view logs, etc.", 
            "title": "Chef's Notes"
        }
    ]
}